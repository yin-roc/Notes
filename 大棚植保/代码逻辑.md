# 1、mower_ctrl 功能包

## 1、heserial.py（串口文件）

### 1.1、涉及自定义消息类型

#### 1.1.1	CtrlComand.msg

行驶速度和转向角度：

```
float32 driving_speed
float32 steering_angle
```



#### 1.1.2	ModeSwitch.msg

目标模式：行驶、转换、旋转

```
uint8 target_mode
uint8 MOTION_MODE_STEERING = 0
uint8 MOTION_MODE_TRANSLATION = 1
uint8 MOTION_MODE_ROTATION = 2
```



#### 1.1.3	SensorValue.msg

传感器的值：==具体含义未知==

```
uint8 col_data1
uint8 col_data2
uint8 col_data3
uint8 col_data4
uint16 ul_data1
uint16 ul_data2
uint16 ul_data3
uint16 ul_data4
uint32 distance
uint8 carpipe
uint8 rollpipe
float32 nowcar_speed
```



### 1.2、程序解析

#### 1.2.1	类

##### 类1：AUTOState（枚举类）

共计四个状态：WAITING（等待）、ALIGNMENT（对齐）、WORK（工作）、START（启动）

```c++
class AUTOState(Enum):
    WAITING = 0       
    ALIGNMENT = 1
    WORK = 2
    START = 3
```



##### 类2：串口控制

###### 方法1：初始化函数

1. 初始化节点名：`hf_serial`，并设置无论如何启动该节点；

2. 初始化串口名称（serial_port， "/dev/ttyTHS1"）、波特率（serial_baudrate，115200）、控制速率或控制频率（control_rate）、ros循环频率（rate，由前者 control_rate 传入）；

3. 初始化时间（==time==）为0；

4. 初始化计数（==ctrl_count_down==）为0；

5. 定义发送指令集（tx_command）

	包括：摄像头未被正确检测、上位机自检无误、设置运动模式为横向、设置运动模式为竖向、上位机对行完成、上位机对行错误、获取当前车辆各模块各状态数据信息、通知上位机开始工作、通知下位机里程计清零、通知上位机退出自动工作、通知上位机暂停工作、通知上位机继续自动工作：

	```c++
	self.tx_command = [
	            "#camera,ERROR*\n", 
	            "#jeston_check,OK*\n", 
	            "set_mode TS\n",
	            "set_mode VT\n",
	            "alignment_ready\n",
	            "alignment_error\n",
	            "read_carinfo\n",
	            "#work_start,OK*\n",
	            "distance_reset\n",
	            "#work_stop,OK*\n",
	            "#work_warning,OK*\n",
	            "#work_continue,OK*\n"
	            ]
	```

6. 初始化传输计数（tx_count）、传输数量（tx_num）、命令行界面时间（CLItime）均为0；

7. 初始化当前工作模式为 start，即开始自动工作；

8. 串口初始化操作，定义串口变量ser，定义串口地址；（serial_port）、波特率（serial_baudrate）以及发送或等待数据的超时时间（timeout=0.5/self.control_rate）；若设置不成功则打印错误信息；

9. 定义发布者：

	1）RX_num_publisher：发送 Int8 类型消息，话题名为 “RX_num”；

	2）RX_info_publisher：发送自定义消息类型为 SensorValue 的消息，话题名为“RX_info”；

	3）carinfo_publisher：发送 string 类型的消息，话题名为“car_info”；

	

10. 定义订阅者：

	1）TX_num_subscriber：订阅话题名为“TX_num”，消息类型为 Int8 的消息，回调函数为 TXHandler ；

	回调函数：

	​		接收 Int8 消息类型的变量为 ==tx_num==；

	​		设置 ==预设tx_num== 为 新传入的 ==tx_num== 值，==tx_count== 计数置零；

	​		当接收到的 ==  == 大于 0 且计数（==tx_count==）为 0 时，打印日志，并将 tx_command 字符串集中 ==tx_num== 对应的数据写入串口，==CLItime== 清零，==tx_count== 计数加1；

	​		当计数 ==tx_count==  为 3 时，清零。

	

	2）ctrl_subscriber：订阅话题名为“ctrl_command”，消息类型为自定义消息类型：CtrlCommand，调用回调函数为 CtrlCommandHandler；

	回调函数：

	​		接收 CtrlCommand消息类型的变量为 ==ctrl_msg==；

	​		如果当前 ctrl_count_down 为 0 且当前车辆状态为 自动工作，设置 driving_speed 为 ctrl_msg 中 driving_speed  四舍五入且保留两位小数的结果；设置 steering_angle为 ctrl_msg 中 steering_angle 四舍五入且保留两位小数的结果；初始化字符串 ctrl_command_str 的内容为 “move <speed> <angle>\n”;

	​		打印该字符串内容，并写入到串口；

	​		设置 ==CLItime== 为 9， self.==ctrl_count_down== 为 1

11. 初始化以下参数

	```python
	self.last_speed = 0
	self.last_angle = 0
	self.last_rspeed = 0
	self.last_wateren = 0
	self.driving_speed = 0
	self.steering_angle = 0
	self.roll_speed = 0
	self.water_en = 0
	```



###### 方法2：析构函数 del

对象销毁前关闭串口



###### 方法3：命令接收函数 RxCommand

接收参数：==num==（类型未知）

打印当前接收到的消息；

初始化 RX_num 内容为 num；

发布者RX_num_publisher 发布 RX_num 。



###### 方法4：==空闲指令函数== FreeCLITxCommand 

如果 CLItime 大于 0 ，则自减 1；否则发送空闲指令 free_command，内容为“CLI_free\n”，打印空闲指令，串口写入空闲指令 free_command，CLItime 置 9。



###### 方法5：主循环 MainLoop

运行前提：ros正在运行

打印当前工作状态；

读取串口信息并存入 feedback 中；

1、当当前状态为 AUTOState.START （开始工作）时，打印start_command（program_started\n） ，并在串口写入该信息，通知下位机：上位机已经准备就绪；CLItime 置 9 。

​				当从串口读入的信息长度大于 1，打印：`RX: + 接收到的内容`；

​						如果读取出来的信息为 `#program_started,OK*\n`，表示通知下位机：上位机决策程序正常启动，并将当前状态设为等待（AUTOState.WAITING）

2、当当前状态为等待（AUTOState.WAITING），如果接受到的串口信息数据长度大于 1，打印：`RX：+ 接收到的内容`；

​				如果接受到的信息刚好为：`auto_work\n`，表示下位机通知上位机：进入自动工作模式：通过 RxCommand 函数调用发布者 RX_num_publisher 发布 1（num的值），当前状态设置为 对齐；

3、当当前状态为对齐（AUTOState.ALIGNMENT），如果从串口接收到的信息长度大于 1，打印：`RX：+ 接收到的内容`

​				如果从串口读取的信息为：`work_start\n`，表示下位机通知上位机：开始自动工作：通过 RxCommand 函数调用发布者 RX_num_publisher 发布 2（num的值），并将当前状态设置为 自动工作（AUTOState.WORK）

​				如果从串口读取的信息为：`work_stop\n`，表示下位机通知上位机：退出自动工作，并且通过 RxCommand 函数调用发布者 RX_num_publisher 发布 3（num的值），并将当前状态设置为 等待（AUTOState.WAITING）

4、当当前状态为自动工作（AUTOState.WORK），如果接受到的串口信息数据长度大于 1，打印：`RX：+ 接收到的内容`；

​				如果从串口读取的信息为：`work_stop\n`，表示下位机通知上位机：退出自动工作，并且通过 RxCommand 函数调用发布者 RX_num_publisher 发布 3（num的值），并将当前状态设置为 等待（AUTOState.WAITING），ctrl_count_down 计数清零；

​				如果从串口读取的信息为：`#set_mode,OK*\n`，表示下位机通知上位机：运动模式设置成功，并且通过 RxCommand 函数调用发布者 RX_num_publisher 发布 4（num的值）；

​				如果从串口读取的信息为：`#distance_reset,OK*\n`，表示下位机通知上位机：里程计清零成功，并且通过 RxCommand 函数调用发布者 RX_num_publisher 发布 5（num的值）；

5、  均不满足上述条件，对从串口读取的数据进行处理：先使用 `*` 作为分隔符，并取拆分后的第一段，再对其使用分隔符 `,` 进行处理，将经过两次拆分的字符串列表赋值给 RX_STR；

​				如果拆分后的第一段内容等于 `#move` && 拆分后的第二段内容等于 `OK`  && 字符串列表的长度为 6：

​						将拆分后的第三段内容保留两位小数后，赋值给 last_speed；

​						将拆分后的第四段内容保留两位小数后，赋值给 last_angle；

​						将拆分后的第五段内容保留整数部分后，赋值给 RX_info（自定义消息类型SensorValue）的 ul_data1；

​						将拆分后的第六段内容保留整数部分后，赋值给 RX_info（自定义消息类型SensorValue）的 ul_data2；

​						调用发布者 RX_info_publisher 发布 RX_info 信息（RX_info）；

​						如果 last_speed 等于 driving_speed && last_angle 等于 steering_angle，打印：`move feedback ok`，并将 ctrl_count_down 清零。

​				拆分后的第一段内容等于 `#read_carinfo` && 拆分后的第二段内容等于 `OK`  && 字符串列表的长度为 44：

​						将从串口读取的信息存入 carinfo，并使用发布者 carinfo_publisher 发布该信息（carinfo）；

​						将拆分后的第18段内容保留整数部分后，赋值给 RX_info（自定义消息类型SensorValue）的 col_data1；

​						将拆分后的第19段内容保留整数部分后，赋值给 RX_info（自定义消息类型SensorValue）的 col_data2；

​						将拆分后的第20段内容保留整数部分后，赋值给 RX_info（自定义消息类型SensorValue）的 col_data3；

​						将拆分后的第21段内容保留整数部分后，赋值给 RX_info（自定义消息类型SensorValue）的 col_data4；

​						将拆分后的第14段内容保留整数部分后，赋值给 RX_info（自定义消息类型SensorValue）的 ul_data1；

​						将拆分后的第15段内容保留整数部分后，赋值给 RX_info（自定义消息类型SensorValue）的 ul_data2；

​						将拆分后的第16段内容保留整数部分后，赋值给 RX_info（自定义消息类型SensorValue）的 ul_data3；

​						将拆分后的第17段内容保留整数部分后，赋值给 RX_info（自定义消息类型SensorValue）的 ul_data4；

​						将拆分后的第22段内容保留整数部分后，赋值给 RX_info（自定义消息类型SensorValue）的 distance；

​						使用发布者 RX_info_publisher发布该信息（RX_info）

6、执行空闲指令函数

7、按照设定频率 rate 循环



## 2、hfflower.py

### 1、涉及的自定义消息类型

#### 1.1	CtrlComand.msg

行驶速度和转向角度：

```
float32 driving_speed
float32 steering_angle
```



#### 1.2	ModeSwitch.msg

目标模式：行驶、转换、旋转

```
uint8 target_mode
uint8 MOTION_MODE_STEERING = 0
uint8 MOTION_MODE_TRANSLATION = 1
uint8 MOTION_MODE_ROTATION = 2
```



#### 1.3	SensorValue.msg

传感器的值：==具体含义未知==

```
uint8 col_data1
uint8 col_data2
uint8 col_data3
uint8 col_data4
uint16 ul_data1
uint16 ul_data2
uint16 ul_data3
uint16 ul_data4
uint32 distance
uint8 carpipe
uint8 rollpipe
float32 nowcar_speed
```



### 2	程序解析

#### 2.1	类

##### 类1：WHEEL（枚举类）

横向（TRANSVERSE）和垂直（VERTICAL）

```cpp
class WHEEL(Enum):
    TRANSVERSE =0
    VERTICAL =1
```



##### 类2：CarTowards（枚举类）

GO（前进）和BACK（后退）

```cpp
class CarTowards(Enum):
    GO =0
    BACK =1
```



##### 类3：AUTOState（枚举类）

在 heserial.py 文件的枚举类 AUTOState 基础上加了 FINISH（结束）==、OVER（）和	ERROR（）==

```cpp
class AUTOState(Enum):
    WAITING = 0       
    ALIGNMENT = 1
    GOWORK = 2
    BACKWORK = 3
    FINISH = 4
    OVER = 5
    ERROR = 6
```



##### 类4：decision（决策）

###### 方法1：初始化函数（init）

1. 初始化节点：hf_decision；

2. 通过外部参数 control_rate 初始化 control_rate，默认为 10；

3. 通过外部参数 ==linear_yk== 初始化 linear_yk，默认为 0.75；

4. 通过外部参数 ==linear_zk== 初始化 linear_zk，默认为 0.25；

5. 通过外部参数 ==linear_allk==初始化 linear_allk，默认为 0.5；

6. 通过外部参数 ==near_ul==初始化 near_ul，默认为 800；

7. 通过外部参数 ==far_ul==初始化 far_ul，默认为 1200；

8. 定义一个 ROS 频率控制器对象，值为 control_rate；

9. 当前机器人的状态由 current_state 存储并初始化为 AUTOState.WAITING；

10. 初始化参数 distance 为 0；

11. 初始化参数 last_distance 为 0；

12. 初始化参数 dis_reset_flag 为 0；

13. 初始化参数 nav_num 为 0；

14. 初始化参数 nav_num1 为 0；

15. 初始化参数 delta_d 为 0；

16. 初始化参数 delta_d1为 0；

17. 初始化参数 speed 为 0；

18. 初始化参数 rx_num 为 0；

19. 初始化参数 setmodenum 为 0；

20. 初始化当前视觉对行情况标志位 leftflag 为 0；

21. 初始化当前视觉对行情况标志位 rightflag 为 0；

22. 初始化当前视觉对行情况标志位 leftnum 为 0；

23. 初始化当前视觉对行情况标志位 rightnum 为 0；

24. 初始化当前各传感器数值 ul_num1 为 0；

25. 初始化当前各传感器数值 ul_num2 为 0；

26. 初始化当前各传感器数值 ul_overtime 为 0；

27. 定义发布者：

	TX_num_publisher：发送 Int8 类型消息，话题名为 “TX_num”；

	ctrl_publisher：发送自定义 CtrlCommand 类型消息，话题名为 “ctrl_command”；

28. 定义订阅者：

	1）twist_subscriber：订阅话题名为“duihang”，消息类型为 Twist 的消息，回调函数为 NavigationHandler；

	回调函数：

	​		接收 Twist 消息类型的变量为 twist_msg；

	​		类中变量 nav_num 数值加1；

	​		类中变量 leftnum 数值等于 5；

	​		如果类中的变量 标志位 ==leftflag== 小于 2：

	​				如果接收到的 twist_msg 的 x 方向上的线速度不等于 0：

	​						==leftflag== 置 1；

	​						delta_d 的变量赋值 `(twist_msg.linear.y * self.linear_yk + twist_msg.linear.z * self.linear_zk) * self.linear_allk`；

	​				如果接收到的 twist_msg 的 x 方向上的线速度等于 0：

	​						==leftflag== 置零。

	

	2）twist_subscriber2：订阅话题名为 `duihang2`，消息类型为 Twist  的消息，回调函数为 NavigationHandler2；

	回调函数：

	​		接收 Twist 消息类型的变量为 twist_msg；

	​		类中变量 ==nav_num1== 数值加1；

	​		类中变量 ==rightnum== 数值等于 5；

	​		如果接收到的 twist_msg 的 x 方向上的线速度不等于 0：

	​				==rightflag== 置 1；

	​				delta_d1 的变量赋值 `(twist_msg.linear.y * self.linear_yk + twist_msg.linear.z * self.linear_zk)*self.linear_allk`；

	​		如果接收到的 twist_msg 的 x 方向上的线速度等于 0：

	​				==rightflag== 置零。

	

	3）twist_subscriber3：订阅话题名为“`duihang3`”，消息类型为 Twist 的消息，回调函数为 NavigationHandler3；

	回调函数：

	​		接收 Twist 消息类型的变量为 twist_msg；

	​		类中变量 nav_num 数值加1；

	​		类中变量 leftnum 数值等于 5；

	​		如果类中的变量 标志位 ==leftflag== 小于 2：

	​				如果接收到的 twist_msg 的 x 方向上的线速度不等于 0：

	​						==leftflag== 置 1；

	​						delta_d 的变量赋值 `(twist_msg.linear.y * self.linear_yk + twist_msg.linear.z * self.linear_zk) * self.linear_allk`；

	​				如果接收到的 twist_msg 的 x 方向上的线速度等于 0：

	​						==leftflag== 置零。

	4）twist_subscriber4：订阅话题名为 `duihang4`，消息类型为 Twist  的消息，回调函数为 NavigationHandler4；

	回调函数：

	​		接收 Twist 消息类型的变量为 twist_msg；

	​		类中变量 ==nav_num1== 数值加1；

	​		类中变量 ==rightnum== 数值等于 5；

	​		如果接收到的 twist_msg 的 x 方向上的线速度不等于 0：

	​				==rightflag== 置 1；

	​				delta_d1 的变量赋值 `(twist_msg.linear.y * self.linear_yk + twist_msg.linear.z * self.linear_zk)*self.linear_allk`；

	​		如果接收到的 twist_msg 的 x 方向上的线速度等于 0：

	​				==rightflag== 置零。

	5）RX_num_subscriber：订阅话题名为 `RX_num`，消息类型为 Int8 的消息，回调函数为 RXHandler（==接收串口信号数值==）；

	回调函数：

	​		接收 Int8 消息类型的变量为 rx_num；

	​		类中变量 ==rx_num== 数值为订阅到的消息 rx_num 中的 data 部分；

	​		在终端打印：rx_num 的值；

	​		如果类中的 rx_num 等于 3：

	​				类中的 rx_num 清零；

	​				如果类中的 launch_state 为 AUTOState.GOWORK：

	​						终止 launchgo 对应的节点；

	​				如果类中的 launch_state 为 AUTOState.BACKWORK：

	​						终止 launchback 对应的节点；

	​				调用 StopToWaitInit() 函数，初始化以下参数：

	​						nav_num = 0；

	​						nav_num1 = 0；

	​						leftflag = 0；

	​						rightflag = 0；

	​						leftnum = 0；

	​						rightnum = 0；

	​						setmodenum = 0；

	​						distance = 0；

	​						dis_reset_flag = 0；

	​						delta_d = 0；

	​						delta_d1 = 0；

	​						speed = 0；

	​						rx_num = 0；

	​				调用 TxCommand() 函数（命令发送）并传入参数 10：

	​						打印日志：tx command num: 10；

	​						将类中的变量 TX_num 初始化为 num（10）；

	​						调用发布者 TX_num_publisher 发布 TX_num；

	​				将当前状态 current_state 设为 AUTOState.WAITING；

	​		如果当前类中的 rx_num 等于 4：

	​				将类中的 setmodenum 设为 1；

	​		如果当前类中的 rx_num 等于 5：

	​				将类中的 dis_reset_flag 设为 1；

	​					

	6）RX_info_subscriber：订阅话题名为 `RX_info`，消息类型为 SensorValue 的消息，回调函数为 InfoHandler（==接收各传感器数值并处理==）；

	回调函数：

	​		接收 SensorValue 消息类型的变量为 msg；

	​		类中变量 ==ul_num1== 为订阅的 msg 中的 ul_data1；

	​		类中变量 ==ul_num2== 为订阅的 msg 中的 ul_data2；

###### 方法2：启动关闭视觉导航程序（Startvisual）

将临时生成的 UUID 赋值给变量 uuid；

将生成的 UUID 传递给 ROS Launch 日志记录系统；

如果接收到的 cartowards 内容为 CarTowards.GO：

​		使用 launchgo 这个变量来标识 hfvisual_go.launch 文件；

​		使用 launchgo 的 start() 方法来启动该文件；

​		将 launch_state 状态设置为 AUTOState.GOWORK；

​		终端打印日志：`go visual started`

如果接收到的 cartowards 内容为 CarTowards.BACK：

​		使用 launchback 这个变量来标识 hfvisual_back.launch 文件；

​		使用 launchback 的 start() 方法来启动该文件；

​		将 launch_state 状态设置为 AUTOState.BACKWORK；

​		终端打印日志：`back visual started`。

​		

###### 方法3：车辆运动控制（MoveCtrl）

将订阅到的 speed 消息 赋值给类中变量 ctrl_command 的 driving_speed 分量；

将订阅到的 angle 消息 赋值给类中变量 ctrl_command 的 steering_angle 分量；

使用发布者 （ctrl_publisher） 发布 类中变量 ctrl_command；

在终端打印：move 和 类中变量 ctrl_command 的 driving_speed 分量。



###### 方法4：车辆模式切换（Setmode）

如果接受订阅消息的 mode 为 WHEEL.TRANSVERSE：

​		调用 TxCommand 方法，传入参数 3，即：

​				终端打印日志：tx command num: 3；

​				类中变量 TX_num 赋值为 3，并通过发布者 TX_num_publisher 发布 TX_num。 

如果接受订阅消息的 mode 为 WHEEL.VERTICAL：

​		调用 TxCommand 方法，传入参数 4，即：

​				终端打印日志：tx command num: 4；

​				类中变量 TX_num 赋值为 4，并通过发布者 TX_num_publisher 发布 TX_num。



###### 方法5：前进时的车辆速度决策处理（SpeedGoHandler）

如果当前的 leftnum 大于等于 0：

​		leftnum 做自减1操作；

如果当前的 leftnum 小于 0：

​		leftflag 置零；

如果当前的 rightnum大于等于 0：

​		rightnum做自减1操作；

如果当前的 rightnum 小于 0：

​		rightflag 置零；

​		终端打印：leftflag

​								rightflag

​		如果类中变量 nav_num < 150 或者 类中变量 nav_num1 < 150 ，并且 类中变量 leftflag 和 类中变量 rightflag 均等于 0：

​				类中变量 ul_overtime 置0，类中变量 speed 取1，类中变量 delta_d 置0.0；

​		如果类中变量 leftflag 等于 1并且 类中变量 rightflag 等于 1：

​				类中变量 ul_overtime 置0，类中变量 speed 取1，类中变量 delta_d 取 类中变量 delta_d 和类中变量 delta_d1的一半值；

​		如果类中变量 leftflag 等于 1并且 类中变量 rightflag 等于 0：

​				类中变量 ul_overtime 置0，类中变量 speed 取1，类中变量 delta_d 不变 ；

​		如果类中变量 leftflag 等于 0 并且 类中变量 rightflag 等于 1：

​				类中变量 ul_overtime 置0，类中变量 speed 取1，类中变量 delta_d 取类中变量 delta_d1；

​		如果类中变量 leftflag 等于 0 并且 类中变量 rightflag 等于 0：

​				类中变量 speed 置 0，类中变量 delta_d 取 0.0；

如果类中变量 speed 为 0，且类中变量 ul_num1 小于等于 类中变量 far_ul 且类中变量 ul_num2 小于等于 类中变量 far_ul ：

​		终端打印日志：now gowork is finish,visual

​		类中变量 nav_num 置0；

​		类中变量 nav_num1置0；

​		关闭 launchgo 所对应的 launch 文件；

​		调用 Startvisual() 函数并将 CarTowards.BACK 传递给函数参数 cartowards：

​				执行对应函数逻辑：

​						使用 launchback 这个变量来标识 hfvisual_back.launch 文件；

​						使用 launchback 的 start() 方法来启动该文件；

​						将 launch_state 状态设置为 AUTOState.BACKWORK；

​						终端打印日志：`back visual started`。

​		类中变量 dis_reset_flag 置 0；

​		类中变量 current_state 设为 AUTOState.BACKWORK；

如果类中变量 speed 为 0，且满足（类中变量 ul_num1 大于等于类中变量 far_ul ） 或者 （类中变量 ul_num2 大于类中变量 far_ul ）之一：

​		类中变量 speed 设为 1.0；

​		类中变量 delta_d 设为 0.0；

类中变量 ul_overtime 自加 1；

如果类中变量 ul_overtime 大于等于 20;

​		类中变量 speed 设为 0.0；

​		关闭 launchgo 对应节点；

​		终端打印日志：now gowork is error；

​		类中变量 current_state 设为 AUTOState.ERROR；

如果（类中变量 ul_num1 小于类中变量 near_ul 并且类中变量 ul_num1 大于 10）或者（类中变量 ul_num2 小于类中变量 near_ul 并且类中变量 ul_num2 大于 10）：

​		类中变量 speed 等于 0.0；

​		类中变量 delta_d 等于 0.0；

​		关闭 launchgo 对应节点；

​		终端打印日志：now gowork is error；

​		类中变量 current_state 设为 AUTOState.ERROR；

调用 MoveCtrl() 函数，将类中变量 speed 和类中变量 delta_d 分别当作函数参数 speed 和 angle 传入：

​		该函数内部逻辑为：

​				将订阅到的 speed 消息 赋值给类中变量 ctrl_command 的 driving_speed 分量；

​				将订阅到的 angle 消息 赋值给类中变量 ctrl_command 的 steering_angle 分量；

​				使用发布者 （ctrl_publisher） 发布 类中变量 ctrl_command；

​				在终端打印：move 和 类中变量 ctrl_command 的 driving_speed 分量。



###### 方法6：后退时的车辆速度决策处理（SpeedBackHandler）

如果当前的 leftnum 大于等于 0：

​		leftnum 做自减1操作；

如果当前的 leftnum 小于 0：

​		leftflag 置零；

如果当前的 rightnum大于等于 0：

​		rightnum做自减1操作；

如果当前的 rightnum 小于 0：

​		rightflag 置零；

​		终端打印：leftflag

​								rightflag

​		如果类中变量 nav_num < 300 或者 类中变量 nav_num1 < 300，并且 类中变量 leftflag 和 类中变量 rightflag 均等于 0：

​				类中变量 ul_overtime 置0，类中变量 speed 取 `-1`，类中变量 delta_d 置0.0；

​		如果类中变量 leftflag 等于 1并且 类中变量 rightflag 等于 1：

​				类中变量 ul_overtime 置0，类中变量 speed 取 `-1`，类中变量 delta_d 取 类中变量 delta_d 和类中变量 delta_d1的一半值；

​		如果类中变量 leftflag 等于 1并且 类中变量 rightflag 等于 0：

​				类中变量 ul_overtime 置0，类中变量 speed 取 `-1`，类中变量 delta_d 不变 ；

​		如果类中变量 leftflag 等于 0 并且 类中变量 rightflag 等于 1：

​				类中变量 ul_overtime 置0，类中变量 speed 取 `-1`，类中变量 delta_d 取类中变量 delta_d1；

​		如果类中变量 nav_num 大于等于 300，且类中变量 nav_num1 大于等于300，且类中变量 leftflag 等于 0 并且 类中变量 rightflag 等于 0 且：

​				类中变量 speed 设为 0.0，类中变量 delta_d 取 0.0；

如果类中变量 speed 为 0，且类中变量 ul_num1 小于等于 类中变量 far_ul 且类中变量 ul_num2 小于等于 类中变量 far_ul ：

​		终端打印日志：now backwork is finish,visual

​		类中变量 nav_num 置0；

​		类中变量 nav_num1置0；

​		关闭 launchback 所对应的 launch 文件；

​		将 launch_state 状态设置为 AUTOState.FINISH；

​						终端打印日志：`back visual started`。

​		类中变量 dis_reset_flag 置 0；

​		类中变量 current_state 设为 AUTOState.BACKWORK；

如果类中变量 speed 为 0.0，且满足（类中变量 ul_num1 大于类中变量 far_ul ） 或者 （类中变量 ul_num2 大于类中变量 far_ul ）之一：

​		类中变量 speed 设为 `-1.0`；

​		类中变量 delta_d 设为 0.0；

类中变量 ul_overtime 自加1；

如果类中变量 ul_overtime 大于等于 20;

​		类中变量 speed 设为 0.0；

​		关闭 launchback 对应节点；

​		终端打印日志：now backwork is error；

​		类中变量 current_state 设为 AUTOState.ERROR；

如果（类中变量 ul_num1 小于类中变量 near_ul 并且类中变量 ul_num1 大于 10）或者（类中变量 ul_num2 小于类中变量 near_ul 并且类中变量 ul_num2 大于 10）：

​		类中变量 speed 等于 0.0；

​		类中变量 delta_d 等于 0.0；

​		关闭 launchback 对应节点；

​		终端打印日志：now backwork is error；

​		类中变量 current_state 设为 AUTOState.ERROR；

调用 MoveCtrl() 函数，将类中变量 speed 和类中变量 `-delta_d` 分别当作函数参数 speed 和 angle 传入：

​		该函数内部逻辑为：

​				将订阅到的 speed 消息 赋值给类中变量 ctrl_command 的 driving_speed 分量；

​				将订阅到的 angle 消息 赋值给类中变量 ctrl_command 的 steering_angle 分量；

​				使用发布者 （ctrl_publisher） 发布 类中变量 ctrl_command；

​				在终端打印：move 和 类中变量 ctrl_command 的 driving_speed 分量。



###### 方法7：StopToWaitInit()

初始化类中变量：

```
nav_num = 0；
nav_num1 = 0；
leftflag = 0；
rightflag = 0；
leftnum = 0；
rightnum = 0；
setmodenum = 0；
distance = 0；
dis_reset_flag = 0；
delta_d = 0；
delta_d1 = 0；
speed = 0；
rx_num = 0
```



###### 方法 8：MainLoop() （主循环参数）

当 ros 节点没有退出：

​		终端打印日志：current_state（类中变量）

​		终端打印日志：near_ul（类中变量）；

​		如果类中变量current_state （当前状态）等于 AUTOState.WAITING：

​				如果类中变量 rx_num 等于 1：

​						将该变量置0；

​						使用 VideoCapture 类来初始化四个视频捕获对象，分别用于从四个不同的视频设备（摄像头）中捕获视频流，四个对象分别为：cap1、cap2、cap3 和 cap4；

​						如果有一个摄像头打开失败，终端打印：`camera is error`；

​								调用 TxCommand() 函数，传入参数 1：

​										终端打印日志：tx command num: 1；

​										类中变量 TX_num 赋值为 1，并通过发布者 TX_num_publisher 发布 TX_num。

​						如果全部连接成功：

​								终端打印日志：`camera is conntect`；

​								使用 release 方法释放摄像头资源；

​								调用 TxCommand() 函数，传入参数 2：

​										终端打印日志：tx command num: 2；

​										类中变量 TX_num 赋值为 2，并通过发布者 TX_num_publisher 发布 TX_num。

​								调用 Startvisual() 函数，并将 CarTowards.GO 作为参数传递给 cartowards：

​										执行对应函数逻辑：

​												使用 launchgo 这个变量来标识 hfvisual_back.launch 文件；

​												使用 launchgo 的 start() 方法来启动该文件；

​												将 launch_state 状态设置为 AUTOState.GOWORK；

​												终端打印日志：`go visual started`。

​								类中变量 current_state 设为 AUTOState.ALIGNMENT；

​		如果类中变量current_state （当前状态）等于 AUTOState.ALIGNMENT：

​				终端打印日志：`leftflag` 的值；

​				终端打印日志：`rightflag` 的值；

​				如果类中变量 rx_num 等于 2：

​						将该变量置0；

​						调用 TxCommand() 函数，传入参数 8：

​								终端打印日志：tx command num: 8；

​								类中变量 TX_num 赋值为 8，并通过发布者 TX_num_publisher 发布 TX_num。

​						类中变量 current_state 设为 `AUTOState.GOWORK`；

​				如果类中变量 nav_num 大于 50 且 类中变量 nav_num1 大于 50 且 类中变量 leftflag 等于0 且 类中变量 rightflag 等于0：

​						终端打印日志：TX: alignment_ready；

​						调用 TxCommand() 函数，传入参数 5：

​								终端打印日志：tx command num: 5；

​								类中变量 TX_num 赋值为 5，并通过发布者 TX_num_publisher 发布 TX_num。	

​		如果类中变量 current_state （当前状态）等于 AUTOState.GOWORK：

​				终端打印日志：`dis_reset_flag`

​				终端打印日志：dis_reset_flag（类中变量的值）

​				如果类中变量 setmodenum 的值为 0：

​						调用方法 Setmode 并传入参数WHEEL.VERTICAL：

​								函数逻辑：

​										调用 TxCommand 方法，传入参数 4，即：

​										终端打印日志：tx command num: 4；

​										类中变量 TX_num 赋值为 4，并通过发布者 TX_num_publisher 发布 TX_num。

​				如果类中变量 setmodenum 的值为 1 且 类中变量 dis_reset_flag 的值为0：

​						设置类中变量 roll_speed 为 1；

​						设置类中变量 speed 为 1；

​						设置类中变量 ul_num1为 0；

​						设置类中变量 ul_num2 为 0；

​						设置类中变量 distance为 0；

​						调用 TxCommand() 函数，传入参数 9：

​								终端打印日志：tx command num: 9；

​								类中变量 TX_num 赋值为 9，并通过发布者 TX_num_publisher 发布 TX_num。

​				如果类中变量 dis_reset_flag 的值为 1：

​						调用函数 SpeedGoHandler()

​		如果类中变量 current_state 为 AUTOState.BACKWORK：

​				如果类中变量 setmodenum 的值为 1 且 类中变量 dis_reset_flag 的值为0：

​						设置类中变量 roll_speed 为 `-1`；

​						设置类中变量 speed 为 `-1`；

​						设置类中变量 ul_num1为 0；

​						设置类中变量 ul_num2 为 0；

​						设置类中变量 distance为 0；

​						调用 TxCommand() 函数，传入参数 9：

​								终端打印日志：tx command num: 9；

​								类中变量 TX_num 赋值为 9，并通过发布者 TX_num_publisher 发布 TX_num。

​				如果类中变量 dis_reset_flag 的值为 1：

​						如果类中变量 nav_num 大于 100 且 类中变量 nav_num1 大于 100：

​								调用函数 SpeedBackHandler()

​						如果类中变量 current_state 等于 AUTOState.FINISH：

​								调用方法 MoveCtrl，并将 speed = 0， angle = 0 当作参数传入：

​										该函数内部逻辑为：

​										将订阅到的 speed 消息 赋值给类中变量 ctrl_command 的 driving_speed 分量；

​										将订阅到的 angle 消息 赋值给类中变量 ctrl_command 的 steering_angle 分量；

​										使用发布者 （ctrl_publisher） 发布 类中变量 ctrl_command；

​										在终端打印：move 和 类中变量 ctrl_command 的 driving_speed 分量。

​		如果类中变量 current_state 为 AUTOState.ERROR：

​				类中变量 nav_num 等于 0；

​				类中变量 nav_num1 等于 0；

​				调用方法 MoveCtrl，并将 speed = 0， angle = 0 当作参数传入：

​						该函数内部逻辑为：

​						将订阅到的 speed 消息 赋值给类中变量 ctrl_command 的 driving_speed 分量；

​						将订阅到的 angle 消息 赋值给类中变量 ctrl_command 的 steering_angle 分量；

​						使用发布者 （ctrl_publisher） 发布 类中变量 ctrl_command；

​						在终端打印：move 和 类中变量 ctrl_command 的 driving_speed 分量。

​		终端打印：ul_num1: ul_num1（类中变量的值）；

​		终端打印：ul_num1: ul_num2（类中变量的值）；

​		终端打印：ul_num1: ul_overtime（类中变量的值）；

​		循环休眠；



## 3、motion.py			

### 1、涉及的自定义消息类型

#### 1.1	CtrlComand.msg

行驶速度和转向角度：

```
float32 driving_speed
float32 steering_angle
```



#### 1.2	ModeSwitch.msg

目标模式：行驶、转换、旋转

```
uint8 target_mode
uint8 MOTION_MODE_STEERING = 0
uint8 MOTION_MODE_TRANSLATION = 1
uint8 MOTION_MODE_ROTATION = 2
```



### 2、程序解析

#### 2.1	类

##### 类1：MotionController

###### 方法1：初始化方法（init）

1. 初始化节点名为：`motion_ctrl`；

2. 获取参数服务器中 `~serial_port` 的值，如果没有，则将类中变量 serial_port 的值设为 `/dev/ttyTHS1`；

3. 获取参数服务器中 `~serial_baudrate` 的值，如果没有，则将类中变量 serial_baudrate 的值设为 115200；

4. 获取参数服务器中 `~control_rate` 的值，如果没有，则将类中变量 control_rate 的值设为 10；

5. 定义一个 ROS 频率器控制对象 rate ，并设置其值为 `control_rate`，即：10

6. 设置类中变量 ctrl_count_down 的值为 0；

7. 设置类中变量 ctrl_command_str 的值为空字符串；

8. 设置类中变量列表 target_mode 的值为 `["ST", "TL", "RT"]`（TS：横向模式、VT：竖向模式和 ==RT==）;

9. 设置类中变量 mode_num 的值为0；

10. 设置类中变量 mode_count 的值为0；

11. 设置类中变量 autoflag 的值为0；

12. 设置类中变量列表 tx_command的值为 

	["#camera,ERROR\*\n", "#jeston_check,OK*\n", "get_distance\n", "distance_reset\n", "alignment_error\n"]

13. 设置类中变量 tx_count 的值为0；

14. 设置类中变量 tx_num 的值为0；

15. 设置类中变量 infocnt 的值为0；

16. 初始化串口（名称、波特率、超时时间），如果失败，在日志中将错误记录为 `ERROR: fail to open control serial port`；

17. 创建发布者：

	1. mode_fb_int8_publisher：发送 Int8 类型消息，话题名为 “mode_fb_num”；
	2. rx_command_publisher：发送 Int8 类型消息，话题名为 “rx_command”；
	3. distance_publisher：发送 Float32 类型消息，话题名为 “distance”；
	4. carinfo_publisher：发送 String 类型消息，话题名为 “car_info”；

18. 创建订阅者：

	1. ctrl_subscriber：

		1. 订阅话题名为“ctrl_command”，消息类型为 CtrlCommand （自定义消息类型）的消息，回调函数为 CtrlCommandHandler；

			回调函数：

			1. 接收 CtrlCommand  消息类型的变量为 ctrl_msg；
			2. 如果类中变量 ctrl_count_down 等于 0：
				1. 对接收到的 ctrl_msg 中的 driving_speed 保留两位小数，赋值给类中变量driving_speed；
				2. 对接收到的 ctrl_msg 中的 steering_angle 保留两位小数，赋值给类中变量steering_angle；
				3. 对 driving_speed 和 steering_angle 进行格式处理，形成字符串`"move ${speed} ${angle}"` 的格式并赋值给类中变量 ctrl_command_str；
				4. 如果类中变量 autoflag 的值等于 1：
					1. 类中变量 ctrl_count_down 清 0；
					2. 终端打印日志："TX: " + 类中变量：ctrl_command_str；
					3. 串口写入类中变量 ctrl_command_str 的值

		2. 订阅话题名为“tx_command”，消息类型为 Int8 的消息，回调函数为 TxCommandHandler；

			回调函数：

			1. 如果类中变量 tx_num 的值不等于 tx_num：
				1. 将 tx_num 赋给类中的变量 tx_num ；
				2. 类中变量 tx_count 清零；
			2. 如果类中变量 tx_count 等于 0 且 tx_num的值大于 0：
				1. 终端打印：tx_command 列表中的元素，元素下标为 tx_num.data-1；
				2. 串口写入 tx_command 列表中的元素，元素下标为 tx_num.data-1；
			3. 类中变量 tx_count 自加1；
			4. 如果类中变量 tx_count 等于 3 ：将该变量清0；

			

	2. mode_subscriber：订阅话题名为“mode_switch”，消息类型为 ModeSwitch（自定义消息类型）的消息，回调函数为 ModeSwitchHandler；

		回调函数：

		1. 接收 CtrlCommand  消息类型的变量为 mode_index消息的 target_mode；
		2. 如果类中变量 mode_num 不等于 mode_index：
			1. 类中变量 mode_num 设为 mode_index 的 target_mode
			2. 类中变量 mode_count 清零
		3. 如果类中变量 mode_count 等于 0：
			1. 类中变量 mode_num 设为 mode_index 消息的 target_mode；
			2. mode_switch_command 的内容设置为 `"set_mode " + self.target_mode[self.mode_num]`（也就是 `"set_mode "` 加上`"ST", "TL", "RT"` 其中之一）；
			3. 终端打印 mode_switch_command 的内容；
			4. 串口写入：mode_switch_command 的内容；
		4. 类中变量 mode_count 的值自加1；
		5. 如果类中变量 mode_count 的值为 3：对其进行清零操作。

19. 类中变量初始化：

	last_speed、last_angle、driving_speed、steering_angle全部清零

	

	

###### 方法2：析构函数（del）

程序结束关闭串口



###### 方法3：SerialCtrlOnce()

终端打印日志：`"TX: " + self.ctrl_command_str`



###### 方法4：CtrlCommandHandler()

1. 接收 CtrlCommand  消息类型的变量为 ctrl_msg；

2. 如果类中变量 ctrl_count_down 等于 0：

	1. 对接收到的 ctrl_msg 中的 driving_speed 保留两位小数，赋值给类中变量driving_speed；

	2. 对接收到的 ctrl_msg 中的 steering_angle 保留两位小数，赋值给类中变量steering_angle；

	3. 对 driving_speed 和 steering_angle 进行格式处理，形成字符串`"move ${speed} ${angle}"` 的格式并赋值给类中变量 ctrl_command_str；

	4. 如果类中变量 autoflag 的值等于 1：

		1. 类中变量 ctrl_count_down 清 0；
		2. 终端打印日志："TX: " + 类中变量：ctrl_command_str；
		3. 串口写入类中变量 ctrl_command_str 的值

		

###### 方法5：TxCommandHandler()

1. 如果类中变量 tx_num 的值不等于 tx_num：
	1. 将 tx_num 赋给类中的变量 tx_num ；
	2. 类中变量 tx_count 清零；
2. 如果类中变量 tx_count 等于 0 且 tx_num的值大于 0：
	1. 终端打印：tx_command 列表中的元素，元素下标为 tx_num.data-1；
	2. 串口写入 tx_command 列表中的元素，元素下标为 tx_num.data-1；
3. 类中变量 tx_count 自加1；
4. 如果类中变量 tx_count 等于 3 ：将该变量清0；



###### 方法6：ModeSwitchHandler()

1. 接收 CtrlCommand  消息类型的变量为 mode_index消息的 target_mode；
2. 如果类中变量 mode_num 不等于 mode_index：
	1. 类中变量 mode_num 设为 mode_index 的 target_mode
	2. 类中变量 mode_count 清零
3. 如果类中变量 mode_count 等于 0：
	1. 类中变量 mode_num 设为 mode_index 消息的 target_mode；
	2. mode_switch_command 的内容设置为 `"set_mode " + self.target_mode[self.mode_num]`（也就是 `"set_mode "` 加上`"ST", "TL", "RT"` 其中之一）；
	3. 终端打印 mode_switch_command 的内容；
	4. 串口写入：mode_switch_command 的内容；
4. 类中变量 mode_count 的值自加1；
5. 如果类中变量 mode_count 的值为 3：对其进行清零操作。



###### 方法7：MainLoop()

节点未关闭：

1. 如果类中变量 autoflag 等于 0：
	1. start_command 赋初值 `program_started\n`；
	2. 终端打印 start_command 的内容；
	3. 串口写入 start_command 的内容。
2. 从串口逐行读取内容，存放入 feedback；
3. 如果读取的 feedback 内容长度大于1：
	1. 终端打印：`"RX: "` + feedback 内容；
	2.  如果 feedback 内容是：`#program_started,OK*\n`：类中变量 autoflag 设为 1；
	3.  如果 feedback 内容是：`auto_work\n`：
		1. 终端打印：`auto work OK` ；
		2. 类中变量 rx_command设为 1；
		3. 使用发布者 rx_command_publisher 发布 类中变量 rx_command；
	4.  如果 feedback 内容是：`stop_work\n`：
		1. 终端打印：`stop work OK` ；
		2. 类中变量 rx_command设为 3；
		3. 使用发布者 rx_command_publisher 发布 类中变量 rx_command；
	5. 如果 feedback 内容是：`#set_mode,OK*\n`：
		1. 终端打印：`mode OK` ；
		2. 类中变量 mode_fb_int8 设为 1；
		3. 使用发布者 mode_fb_int8_publisher 发布 类中变量 mode_fb_int8；
	6. 如果 feedback 内容是：`#distance_reset,OK*\n`：
		1. 终端打印：`reset OK` ；
		2. 类中变量 rx_command 设为 2；
		3. 使用发布者 rx_command_publisher 发布 类中变量 rx_command；
	7. 除去以上情况：
		1. 对 feedback 先按 `*` 分段，并取第一段，按照 `,` 再次进行分段，最后将分段的结果赋值给列表 RX_DIS；
		2. 如果 RX_DIS 的第一段是 `#get_distance`，并且 RX_DIS 的第二段是 `OK`：
			1. 将 RX_DIS 的第三段转化为浮点型，并赋值给类中变量 distance；
			2. 终端打印：类中变量 distance 的值；
			3. 使用发布者 distance_publisher 发布类中变量 distance； 
		3. 如果 RX_DIS 的第一段是 `#move`，并且 RX_DIS 的第二段是 `OK`：
			1. 将 RX_DIS 的第 3 段转化为浮点型，并保留两位小数，处理后的数据赋值给类中变量 last_speed；
			2. 将 RX_DIS 的第 4 段转化为浮点型，并保留两位小数，处理后的数据赋值给类中变量 last_angle；
			3. 终端打印：`speed:` 加上类中变量 last_speed 的值；
			4. 终端打印：`angle:` 加上类中变量 last_angle 的值；
			5. 如果类中变量 last_speed 等于类中变量 driving_speed 并且类中变量 last_angle 等于类中变量 steering_angle：类中变量 ctrl_count_down 清 0；
		4. 如果 RX_DIS 的第一段是 `#read_carinfo`，并且 RX_DIS 的第二段是 `OK`：
			1. 类中变量 carinfo 设为 feedback；
			2. ==如果发布者 carinfo_publisher 发布类中变量 carinfo；==（是否行对错？该文件第164行）
4. 如果类中变量 autoflag 的值为 1
	1. 如果类中变量 infocnt 的值为 0：
		1. carinfo_command 赋值为 `read_carinfo\n`；
		2. 终端打印 carinfo_command 的值；
		3. 向串口写入  carinfo_command 的值；
		4. 类中变量 infocnt 自加 1
	2. 如果类中变量 infocnt 的值不为 0：
		1. 类中变量 infocnt 自加 1
		2. 如果类中变量 infocnt 的值等于 15：
			1. 类中变量 infocnt 的值清零
5. 按照 rate 设置的频率循环休眠



## 4、joystick_ctrl.py

### 1、涉及的自定义消息类型

#### 1.1	CtrlComand.msg

行驶速度和转向角度：

```
float32 driving_speed
float32 steering_angle
```



#### 1.2	ModeSwitch.msg

目标模式：行驶、转换、旋转

```
uint8 target_mode
uint8 MOTION_MODE_STEERING = 0
uint8 MOTION_MODE_TRANSLATION = 1
uint8 MOTION_MODE_ROTATION = 2
```



### 2、程序解析

#### 类

##### 类1：JoystickCtrl

###### 方法1：初始化（init）

1. 初始化节点，设为匿名，设置为：joystick_ctrl；

2. 类中列表变量 previous_buttons 设为 [0, 0, 0, 0]；

3. 类中变量 speed_range 从参数服务器中获取 `~speed_range`，默认为 1；

4. 类中变量 angle_range 从参数服务器中获取 `~angle_range`，默认为 1；

5. 创建订阅者：

	1. joystick_subscriber：订阅话题名为“joy”，消息类型为 Joy（sensor_msgs）的消息，回调函数为 JoystickMsgHandler；

		回调函数：

		1. 接收 Joy 消息类型的变量为 joystick_msg；

		2. 尝试：

			1. 将类中变量 ctrl_command 的分量 steering_angle 设为 `-1 * joystick_msg.axes[0] * self.angle_range` 的值；
			2. 将类中变量 ctrl_command 的分量 driving_speed 设为 `joystick_msg.axes[3] * self.speed_range` 的值；
			3. 调用 ctrl_publisher 发布者发布类中变量 ctrl_command 的内容；

		3. 设置失败则日志中记录：`ERROR: fail to control by joystick`

		4. 如果  joystick_msg 的分量 axes[5] 的值转换为 int 后 不等于 0 ：

			1.  如果类中变量  joystick_msg 的分量 buttons[0] 的值等于 1且类中变量 previous_buttons[0] 的值等于 0 ：
				1. 设置类中变量 mode_switch 的分量 target_mode 的值为 ModeSwitch.MOTION_MODE_STEERING；
				2. 调用发布者 mode_publisher 发布类中变量 mode_switch 的值；
			2. 如果类中变量  joystick_msg 的分量 buttons[1] 的值等于 1且类中变量 previous_buttons[1] 的值等于 0 ：
				1. 设置类中变量 mode_switch 的分量 target_mode 的值为 ModeSwitch.MOTION_MODE_TRANSLATION；
				2. 调用发布者 mode_publisher 发布类中变量 mode_switch 的值；
			3. 如果类中变量  joystick_msg 的分量 buttons[2] 的值等于 1且类中变量 previous_buttons[2] 的值等于 0 ：
				1. 设置类中变量 mode_switch 的分量 target_mode 的值为 ModeSwitch.MOTION_MODE_ROTATION；
				2. 调用发布者 mode_publisher 发布类中变量 mode_switch 的值；
			4. 不满足上述条件，不执行任何操作。

		5. 更新类中变量 previous_buttons 中的值：具体为存储当前值为下一步的先前值：

			```python
			self.previous_buttons[0] = int(joystick_msg.buttons[0])
			self.previous_buttons[1] = int(joystick_msg.buttons[1])
			self.previous_buttons[2] = int(joystick_msg.buttons[2])
			```

6. 定义类中变量 ctrl_command 的类型为 CtrlCommand()（自定义消息类型）

7. 定义类中变量 mode_switch 的类型为 ModeSwitch()（自定义消息类型）

8. 创建发布者：

	1. ctrl_publisher：发送 CtrlCommand 类型消息，话题名为 “ctrl_command”；
	2. mode_publisher：发送 ModeSwitch 类型消息，话题名为 “mode_switch”；



###### 方法2：JoystickMsgHandler()

1. 接收 Joy 消息类型的变量为 joystick_msg；

2. 尝试：

	1. 将类中变量 ctrl_command 的分量 steering_angle 设为 `-1 * joystick_msg.axes[0] * self.angle_range` 的值；
	2. 将类中变量 ctrl_command 的分量 driving_speed 设为 `joystick_msg.axes[3] * self.speed_range` 的值；
	3. 调用 ctrl_publisher 发布者发布类中变量 ctrl_command 的内容；

3. 设置失败则日志中记录：`ERROR: fail to control by joystick`

	

	如果  joystick_msg 的分量 axes[5] 的值转换为 int 后 不等于 0 ：

	1.  如果类中变量  joystick_msg 的分量 buttons[0] 的值等于 1且类中变量 previous_buttons[0] 的值等于 0 ：
		1. 设置类中变量 mode_switch 的分量 target_mode 的值为 ModeSwitch.MOTION_MODE_STEERING；
		2. 调用发布者 mode_publisher 发布类中变量 mode_switch 的值；
	2. 如果类中变量  joystick_msg 的分量 buttons[1] 的值等于 1且类中变量 previous_buttons[1] 的值等于 0 ：
		1. 设置类中变量 mode_switch 的分量 target_mode 的值为 ModeSwitch.MOTION_MODE_TRANSLATION；
		2. 调用发布者 mode_publisher 发布类中变量 mode_switch 的值；
	3. 如果类中变量  joystick_msg 的分量 buttons[2] 的值等于 1且类中变量 previous_buttons[2] 的值等于 0 ：
		1. 设置类中变量 mode_switch 的分量 target_mode 的值为 ModeSwitch.MOTION_MODE_ROTATION；
		2. 调用发布者 mode_publisher 发布类中变量 mode_switch 的值；
	4. 不满足上述条件，不执行任何操作。

4. 更新类中变量 previous_buttons 中的值：具体为存储当前值为下一步的先前值：

	```python
	self.previous_buttons[0] = int(joystick_msg.buttons[0])
	self.previous_buttons[1] = int(joystick_msg.buttons[1])
	self.previous_buttons[2] = int(joystick_msg.buttons[2])
	```



###### 3、方法3：MainLoop()

循环



## 5、lining_ctrl.py

### 1、涉及的自定义消息类型

#### 1.1	CtrlComand.msg

行驶速度和转向角度：

```
float32 driving_speed
float32 steering_angle
```



#### 1.2	ModeSwitch.msg

目标模式：行驶、转换、旋转

```
uint8 target_mode
uint8 MOTION_MODE_STEERING = 0
uint8 MOTION_MODE_TRANSLATION = 1
uint8 MOTION_MODE_ROTATION = 2
```



### 2、程序解析

#### 类

##### 类1：PDController()

###### 方法1：初始化（init）（参数列表：`kp`，`kd`，`output_max`）

1. 类中变量 kp 的值设为传入参数 kp；
2. 类中变量 kd 的值设为传入参数 kd；
3. 类中变量 output_max 的值设为传入参数 output_max；
4. 类中列表变量 error 的值初始化为 `[0, 0, 0]`；
5. 类中变量 feedback 的值设为 0；
6. 类中变量 reference 的值设为 0；
7. 类中变量 output 的值设为 0；



###### 方法2：Clear()（清零方法）

1. 类中列表变量 error 的值设为 `[0, 0, 0]`；
2. 类中变量 feedback 的值设为传入参数 0；
3. 类中变量 reference 的值设为传入参数 0；



###### 方法3：CalcError()

1. 类中列表变量 error 的第2个参数 为 列表变量 error 的第1个参数值；
2. 类中列表变量 error 的第1个参数为类中变量 reference 减去类中变量 feedback 的值；



###### 方法4：CalcOutPut()

1. 类中列表变量 output 的值为 `self.error[0] * self.kp + (self.error[0] - self.error[1]) * self.kd`；

	这个公式是**离散时间PID控制器**的一部分。它用来计算PID控制器的输出。具体来说：

	1. self.error[0] 表示当前时刻的误差（偏差）值。
	2. self.error[1] 表示上一个时刻的误差（偏差）值。
	3. self.kp 是比例增益（Proportional gain）。
	4. self.kd 是微分增益（Derivative gain）。
	5. 公式的第一部分 self.error[0] * self.kp 计算了比例控制器的输出，即根据当前误差值计算出的控制量。

	公式的第二部分 (self.error[0] - self.error[1]) * self.kd 计算了微分控制器的输出，即当前误差值与上一个时刻的误差值之差乘以微分增益。

	这两部分的和即为PID控制器的输出，用来调节系统以减小误差。

2. 保持类中变量 output 的值始终在区间 `[-output_max, output_max]` 中，超出范围，则设为最接近的区间边界值。



##### 类2： LiningState(枚举类)

```
WAITING = 0         # 等待路线信息
LINING = 1          # 跟随线路
LEAVE = 2           # 离开线路
SWITCHING = 3       # 切换线路
ERROR = 4           # 线路错误
```



##### 类3：LiningController

###### 方法1：初始化（init）

1. 初始化 ros 匿名节点为 lining_ctrl； 

2. 初始化类中变量 d_weight 的值为参数服务器中的 `~d_weight`，未找到设为 1；

3.  初始化类中变量 theta_weight 的值为 `1 - self.d_weight`；

4. 初始化类中变量 kp 的值为参数服务器中的 `~kp` 值，未找到设为 `-0.5`；

5. 初始化类中变量 kd 的值为参数服务器中的 `~kd` 值，未找到设为 `-13.3`；

6. 初始化类中变量 place_length 的值为参数服务器中的 `~place_length` 值，未找到设为 `5`；

7. 初始化类中变量 place_width 的值为参数服务器中的 `~place_width` 值，未找到设为 `4`；

8. 初始化类中变量 lining_speed 的值为参数服务器中的 `~lining_speed` 值，未找到设为 `1`；

9. 初始化类中变量 control_rate 的值为参数服务器中的 `~control_rate` 值，未找到设为 `10`；

10. 初始化ROS 频率控制器 rate 的值为类中变量 `control_rate` 值；

11. 初始化类中变量 timeout 的值为参数服务器中的 `~timeout`值 * 1000，未找到设为 `1`；

12. 初始化类中变量 timeout_cnt 的值为类中变量 `timeout` 值； 

13. 初始化类中变量 autoflag 的值为 0；

14.  初始化类 PDController的 对象 PD_controller 的值为 PDController(self.kp, self.kd, 1)；

15. 初始化类中变量 lining_flag 的值为 `LiningState.WAITING`； 

16. 初始化类中变量 distance 的值为 0；

17.  初始化类中变量 dis_reset_flag 的值为 0；

18.  初始化类中变量 rx_command_num 的值为 0；

19.  初始化类中变量 mode_change_value 的值为 0；

20.  初始化类中变量 switch_time 的值为当前时间戳；

21.  初始化类中变量 leaveflag 的值为 0；

22.  初始化类中变量 last_distance 的值为 10000；

23. 创建发布者：

	1. ctrl_publisher：发送 CtrlCommand 类型消息，话题名为 “ctrl_command”；

	2. mode_publisher：发送 ModeSwitch 类型消息，话题名为 “mode_switch”；

		​        将 mode_switch 的 target_mode 分量设为 `ModeSwitch.MOTION_MODE_STEERING`；

	3. tx_command_publisher：发送 ModeSwitch 类型消息，话题名为 “tx_command”；

24. 创建订阅者：

	1. twist_subscriber：订阅话题名为“duihang”，消息类型为 Twist 的消息，回调函数为 LiningMsgHandler；

		回调函数：

		1. 接收 Twist 消息类型的变量为 twist_msg；
		2. 类中变量 timeout_cnt 设置为 类中变量 timeout 的值；
		3. 如果类中变量 lining_flag 等于 `LiningState.LINING`：
			1. 如果类中变量 twist_msg 的分量 linear.x 的值不等于 0：
				1. weighted_angle 的值为 `twist_msg.angular.y * self.d_weight + twist_msg.angular.z * self.theta_weight`；
				2. 类 PDController 对象 PD_controller 的 feedback 值为上述的 weighted_angle；
				3. 类中变量 leaveflag 的值为0；
				4. 类中变量 lining_speed 的值为 0.7；
			2. 否则：
				1. 对象 PD_controller 中的部分值（error、feedback 和 reference）全部清0；
				2. 如果 leaveflag 值为 0：
					1. 将 leaveflag 置1；
					2. 将 last_distance 置为类中变量 distance 的值；
					3. 终端打印：`leave======================================flag`；
					4. 终端打印：类中变量 last_distance 的值
				3. 类中变量 lining_speed 的值设为 0.7；
		4. 如果类中变量 lining_flag 等于 `LiningState.WAITING`：
			1. 如果类中变量 twist_msg 的分量 linear.x 的值不等于 0：
				1. 类中变量 lining_flag 设为 `LiningState.LINING`
				2. weighted_angle 的值为 `twist_msg.angular.y * self.d_weight + twist_msg.angular.z * self.theta_weight`；
				3. 类 PDController 对象 PD_controller 的 feedback 值为上述的 weighted_angle；
				4. 类中变量 leaveflag 的值为0；
				5. 类中变量 lining_speed 的值为 0.7；
				6. 终端打印：`ready lining`。
			2. 否则：
				1. 对象 PD_controller 中的部分值（error、feedback 和 reference）全部清0；
				2. 调用类的 TxCommand() 方法，传入参数5：
					1. 终端打印：`tx command num:`
					2. 终端打印：`num` 的值；
					3. 类中变量 tx_command 的值设为 num；
					4. 使用发布者 tx_command_publisher 发布类中变量 tx_command 的值。
				3. 终端打印：`error state`。

	2. sub_mode_fb：订阅话题名为“mode_fb_num”，消息类型为 Int8 的消息，回调函数为 ModeFbHandler；

		回调函数：

		1. 接收 Int8 消息类型的变量为 mode_fb；
		2. 类中变量 mode_change_value 的值设为 mode_fb 中的data 内容；
		3. 终端打印：`mode change ok`。

	3. sub_rx_command：订阅话题名为“rx_command”，消息类型为 Int8 的消息，回调函数为 RxCommandHandler；

		回调函数：

		1. 接收 Int8 消息类型的变量为 rx_num；
		2. 类中变量 rx_command_num 的值设为 rx_num 中的data 内容；
		3. 终端打印：`rx command num ok`；
		4. 终端打印：类中变量 rx_command_num 的值。

	4. sub_distance：订阅话题名为“distance”，消息类型为 Float32 的消息，回调函数为 GetDistanceHandler；

		回调函数：

		1. 接收 Float32 消息类型的变量为 dis；
		2. 类中变量 distance 的值设为 dis 中的data 内容；
		3. 终端打印：`get distance:`
		4. 终端打印：类中变量 distance 的值。

###### 方法2：LiningMsgHandler()

1. 接收 Twist 消息类型的变量为 twist_msg；
2. 类中变量 timeout_cnt 设置为 类中变量 timeout 的值；
3. 如果类中变量 lining_flag 等于 `LiningState.LINING`：
	1. 如果类中变量 twist_msg 的分量 linear.x 的值不等于 0：
		1. weighted_angle 的值为 `twist_msg.angular.y * self.d_weight + twist_msg.angular.z * self.theta_weight`；
		2. 类 PDController 对象 PD_controller 的 feedback 值为上述的 weighted_angle；
		3. 类中变量 leaveflag 的值为0；
		4. 类中变量 lining_speed 的值为 0.7；
	2. 否则：
		1. 对象 PD_controller 中的部分值（error、feedback 和 reference）全部清0；
		2. 如果 leaveflag 值为 0：
			1. 将 leaveflag 置1；
			2. 将 last_distance 置为类中变量 distance 的值；
			3. 终端打印：`leave======================================flag`；
			4. 终端打印：类中变量 last_distance 的值
		3. 类中变量 lining_speed 的值设为 0.7；
4. 如果类中变量 lining_flag 等于 `LiningState.WAITING`：
	1. 如果类中变量 twist_msg 的分量 linear.x 的值不等于 0：
		1. 类中变量 lining_flag 设为 `LiningState.LINING`
		2. weighted_angle 的值为 `twist_msg.angular.y * self.d_weight + twist_msg.angular.z * self.theta_weight`；
		3. 类 PDController 对象 PD_controller 的 feedback 值为上述的 weighted_angle；
		4. 类中变量 leaveflag 的值为0；
		5. 类中变量 lining_speed 的值为 0.7；
		6. 终端打印：`ready lining`。
	2. 否则：
		1. 对象 PD_controller 中的部分值（error、feedback 和 reference）全部清0；
		2. 调用类的 TxCommand() 方法，传入参数5：
			1. 终端打印：`tx command num:`
			2. 终端打印：`num` 的值；
			3. 类中变量 tx_command 的值设为 num；
			4. 使用发布者 tx_command_publisher 发布类中变量 tx_command 的值。
		3. 终端打印：`error state`



###### 方法3：ModeFbHandler()

1. 接收 Int8 消息类型的变量为 mode_fb；
2. 类中变量 mode_change_value 的值设为 mode_fb 中的data 内容；
3. 终端打印：`mode change ok`。



###### 方法4：RxCommandHandler()

1. 接收 Int8 消息类型的变量为 rx_num；
2. 类中变量 rx_command_num 的值设为 rx_num 中的data 内容；
3. 终端打印：`rx command num ok`；
4. 终端打印：类中变量 rx_command_num 的值。



###### 方法5：GetDistanceHandler()

1. 接收 Float32 消息类型的变量为 dis；
2. 类中变量 distance 的值设为 dis 中的data 内容；
3. 终端打印：`get distance:`
4. 终端打印：类中变量 distance 的值。



###### 方法6：ControlOnce()

话题超时处理：

1. 如果类中变量 timeout_cnt 的值大于 0：
	1. 类中变量 timeout_cnt 的值 减去 1000 / self.control_rate；
2. 否则：
	1. 类中变量 lining_flag 的值设为 `LiningState.WAITING`；
	2. 对象 PD_controller 中的部分值（error、feedback 和 reference）全部清0；
	3. 终端打印：`error state: lining topic timeout`

路线控制：

1. 如果类中变量 lining_flag 的值等于`LiningState.LINING`：

	1. 终端打印：`start lining`；
	2. 如果类中变量 rx_command_num 的值等于 2 ，并且类中变量 dis_reset_flag 的值等于 0，并且类中变量 mode_change_value 的值等于 1：
		1. 类中变量 dis_reset_flag 的值等于 1
	3. 如果类中变量 dis_reset_flag 的值等于 0 ，并且类中变量 mode_change_value 的值等于 1：
		1. 类中变量 distance 的值等于 0;
		2. 调用类的 TxCommand() 方法，传入参数4：
			1. 终端打印：`tx command num:`
			2. 终端打印：`num` 的值；
			3. 类中变量 tx_command 的值设为 num；
			4. 使用发布者 tx_command_publisher 发布类中变量 tx_command 的值。
	4. 如果类中变量 mode_change_value 的值等于 0 ：
		1. 调用方法 `SwitchModeCtrl()`，传入参数 `ModeSwitch.MOTION_MODE_STEERING`：
			1. 接收 ModeSwitch (自定义消息类型)消息类型的变量为 mode； 
			2. 终端打印：`set mode num:`；
			3. 终端打印：mode 的值；
			4. 设置类中变量 mode_switch 的分量 target_mode 的值为 mode；
			5. 调用发布者 mode_publisher 发布类中变量 mode_switch 的值。
	5. 如果类中变量 distance 的值大于等于 6000：
		1. 调用 MoveCtrl() 方法，传入参数（0，0），即：速度(speed)和角度(angle)：
			1. 接收参数的变量为 speed 和 angle；
			2. 类中变量 ctrl_command 的分量 driving_speed 设为 speed；
			3. 类中变量 ctrl_command 的分量 steering_angle 设为 angle；
			4. 调用发布者 tx_command_publisher 发布类中变量 tx_command 的值；
		2. 类中变量 lining_flag 的值设为 `LiningState.LEAVE`；
		3. 类中变量 rx_command_num 的值设为 0；
		4. 类中变量 dis_reset_flag 的值设为 0；
		5. 类中变量 mode_change_value 的值设为 0；
	6. 如果类中变量 distance 的值大于等于 3000：
		1. 终端打印：`delta dis:`；
		2. 终端打印：类中变量 distance 的值减去 类中变量 last_distance；
		3. 类中变量 lining_flag 的值设为 `LiningState.LEAVE`；
		4. 类中变量 rx_command_num 的值设为 0；
		5. 类中变量 dis_reset_flag 的值设为 0；
		6. 类中变量 mode_change_value 的值设为 0；
		7. 调用 MoveCtrl() 方法，传入参数（0，0），即：速度(speed)和角度(angle)：
			1. 接收参数的变量为 speed 和 angle；
			2. 类中变量 ctrl_command 的分量 driving_speed 设为 speed；
			3. 类中变量 ctrl_command 的分量 steering_angle 设为 angle；
			4. 调用发布者 tx_command_publisher 发布类中变量 tx_command 的值；
	7. 不满足以上情况，则：
		1. 终端打印：`delta dis:`；
		2. 终端打印：类中变量 distance 的值减去 类中变量 last_distance；
		3. 调用对象 PD_controller 的 CalcError() 方法：
			1. 类中列表变量 error 的第2个参数 为 列表变量 error 的第1个参数值；
			2. 类中列表变量 error 的第1个参数为类中变量 reference 减去类中变量 feedback 的值。
		4. 调用对象 PD_controller 的 CalcOutPut() 方法：
			1. 类中列表变量 output 的值为 `self.error[0] * self.kp + (self.error[0] - self.error[1]) * self.kd`；
			2. 保持类中变量 output 的值始终在区间 `[-output_max, output_max]` 中，超出范围，则设为最接近的区间边界值。
		5. 调用 MoveCtrl() 方法，传入参数（类中变量 lining_speed，类中变量 PD_controller 的 output），即：速度(speed)和角度(angle)：
			1. 接收参数的变量为 speed 和 angle；
			2. 类中变量 ctrl_command 的分量 driving_speed 设为 speed；
			3. 类中变量 ctrl_command 的分量 steering_angle 设为 angle；
			4. 调用发布者 tx_command_publisher 发布类中变量 tx_command 的值；
		6. 调用类的 TxCommand() 方法，传入参数 3：
			1. 终端打印：`tx command num:`
			2. 终端打印：`num` 的值；
			3. 类中变量 tx_command 的值设为 num；
			4. 使用发布者 tx_command_publisher 发布类中变量 tx_command 的值。

2. 如果类中变量 lining_flag 的值等于`LiningState.LEAVE`：

	1. 终端打印：`leave the line`；
	2. 如果类中变量 rx_command_num 的值等于 2 ，并且类中变量 dis_reset_flag 的值等于 0，并且类中变量 mode_change_value 的值等于 1：
		1. 设置 dis_reset_flag 为1
	3. 如果类中变量 dis_reset_flag 的值等于 0 ，并且类中变量 mode_change_value 的值等于 1：
		1. 类中变量 distance 的值等于 0;
		2. 调用类的 TxCommand() 方法，传入参数4：
			1. 终端打印：`tx command num:`
			2. 终端打印：`num` 的值；
			3. 类中变量 tx_command 的值设为 num；
			4. 使用发布者 tx_command_publisher 发布类中变量 tx_command 的值。
	4. 如果类中变量 mode_change_value 的值等于 0 ：
		1. 调用方法 `SwitchModeCtrl()`，传入参数 `ModeSwitch.MOTION_MODE_ROTATION`：
			1. 接收 ModeSwitch (自定义消息类型)消息类型的变量为 mode； 
			2. 终端打印：`set mode num:`；
			3. 终端打印：mode 的值；
			4. 设置类中变量 mode_switch 的分量 target_mode 的值为 mode；
			5. 调用发布者 mode_publisher 发布类中变量 mode_switch 的值。
	5. 如果类中变量 distance 的值大于等于 3100.0：
		1. 调用 MoveCtrl() 方法，传入参数（0，0），即：速度(speed)和角度(angle)：
			1. 接收参数的变量为 speed 和 angle；
			2. 类中变量 ctrl_command 的分量 driving_speed 设为 speed；
			3. 类中变量 ctrl_command 的分量 steering_angle 设为 angle；
			4. 调用发布者 tx_command_publisher 发布类中变量 tx_command 的值；
		2. 类中变量 lining_flag 的值设为 `LiningState.SWITCHING`；
		3. 类中变量 rx_command_num 的值设为 0；
		4. 类中变量 dis_reset_flag 的值设为 0；
		5. 类中变量 mode_change_value 的值设为 0；
	6. 不满足以上情况，则：
		1. 调用 MoveCtrl() 方法，传入参数（0.5，0），即：速度(speed)和角度(angle)：
			1. 接收参数的变量为 speed 和 angle；
			2. 类中变量 ctrl_command 的分量 driving_speed 设为 speed；
			3. 类中变量 ctrl_command 的分量 steering_angle 设为 angle；
			4. 调用发布者 tx_command_publisher 发布类中变量 tx_command 的值；
		2. 调用类的 TxCommand() 方法，传入参数 3：
			1. 终端打印：`tx command num:`
			2. 终端打印：`num` 的值；
			3. 类中变量 tx_command 的值设为 num；
			4. 使用发布者 tx_command_publisher 发布类中变量 tx_command 的值。

	

3. 如果类中变量 lining_flag 的值等于`LiningState.SWITCHING`：

	1. 终端打印：`switching the line`；
	2. 如果类中变量 rx_command_num 的值等于 2 ，并且类中变量 dis_reset_flag 的值等于 0，并且类中变量 mode_change_value 的值等于 1：
		1. 设置 dis_reset_flag 为1
	3. 如果类中变量 dis_reset_flag 的值等于 0 ，并且类中变量 mode_change_value 的值等于 1：
		1. 类中变量 distance 的值等于 0;
		2. 调用类的 TxCommand() 方法，传入参数4：
			1. 终端打印：`tx command num:`
			2. 终端打印：`num` 的值；
			3. 类中变量 tx_command 的值设为 num；
			4. 使用发布者 tx_command_publisher 发布类中变量 tx_command 的值。
	4. 如果类中变量 mode_change_value 的值等于 0 ：
		1. 调用方法 `SwitchModeCtrl()`，传入参数 `ModeSwitch.MOTION_MODE_TRANSLATION`：
			1. 接收 ModeSwitch (自定义消息类型)消息类型的变量为 mode； 
			2. 终端打印：`set mode num:`；
			3. 终端打印：mode 的值；
			4. 设置类中变量 mode_switch 的分量 target_mode 的值为 mode；
			5. 调用发布者 mode_publisher 发布类中变量 mode_switch 的值。
		2. 类中变量 switch_time 的值设为当前时间戳；
	5. 如果类中变量 mode_change_value 的值等于 1，并且类中变量 dis_reset_flag 的值等于 1，并且当前时间戳 `-` 类中变量switch_time 的结果小于等于2：
		1. 调用 MoveCtrl() 方法，传入参数`（0，1）`，即：速度(speed)和角度(angle)：
			1. 接收参数的变量为 speed 和 angle；
			2. 类中变量 ctrl_command 的分量 driving_speed 设为 speed；
			3. 类中变量 ctrl_command 的分量 steering_angle 设为 angle；
			4. 调用发布者 tx_command_publisher 发布类中变量 tx_command 的值；
	6. 如果类中变量 distance 的值大于等于 1350.0：
		1. 调用 MoveCtrl() 方法，传入参数（0，0），即：速度(speed)和角度(angle)：
			1. 接收参数的变量为 speed 和 angle；
			2. 类中变量 ctrl_command 的分量 driving_speed 设为 speed；
			3. 类中变量 ctrl_command 的分量 steering_angle 设为 angle；
			4. 调用发布者 tx_command_publisher 发布类中变量 tx_command 的值；
		2. 类中变量 lining_flag 的值设为 `LiningState.LINING`；
		3. 类中变量 rx_command_num 的值设为 0；
		4. 类中变量 dis_reset_flag 的值设为 0；
		5. 类中变量 mode_change_value 的值设为 0；
		6. 类中变量 switch_time 的值设为当前时间戳；
	7. 不满足以上情况，则：
		1. 调用 MoveCtrl() 方法，传入参数（0.5，1），即：速度(speed)和角度(angle)：
			1. 接收参数的变量为 speed 和 angle；
			2. 类中变量 ctrl_command 的分量 driving_speed 设为 speed；
			3. 类中变量 ctrl_command 的分量 steering_angle 设为 angle；
			4. 调用发布者 tx_command_publisher 发布类中变量 tx_command 的值；
		2. 调用类的 TxCommand() 方法，传入参数 3：
			1. 终端打印：`tx command num:`
			2. 终端打印：`num` 的值；
			3. 类中变量 tx_command 的值设为 num；
			4. 使用发布者 tx_command_publisher 发布类中变量 tx_command 的值。

4. 不满足上述情况：

	1. 调用 MoveCtrl() 方法，传入参数（0，0），即：速度(speed)和角度(angle)：
		1. 接收参数的变量为 speed 和 angle；
		2. 类中变量 ctrl_command 的分量 driving_speed 设为 speed；
		3. 类中变量 ctrl_command 的分量 steering_angle 设为 angle；
		4. 调用发布者 tx_command_publisher 发布类中变量 tx_command 的值；



###### 方法7：MoveCtrl()（参数：speed，angle）

1. 接收参数的变量为 speed 和 angle；
2. 类中变量 ctrl_command 的分量 driving_speed 设为 speed；
3. 类中变量 ctrl_command 的分量 steering_angle 设为 angle；
4. 调用发布者 tx_command_publisher 发布类中变量 tx_command 的值；



###### 方法8：TxCommand () （参数：num）

1. 终端打印：`tx command num:`
2. 终端打印：`num` 的值；
3. 类中变量 tx_command 的值设为 num；
4. 使用发布者 tx_command_publisher 发布类中变量 tx_command 的值。



###### 方法9：SwitchModeCtrl()（参数：mode）

1. 接收 ModeSwitch (自定义消息类型)消息类型的变量为 mode； 
2. 终端打印：`set mode num:`；
3. 终端打印：mode 的值；
4. 设置类中变量 mode_switch 的分量 target_mode 的值为 mode；
5. 调用发布者 mode_publisher 发布类中变量 mode_switch 的值。



###### 方法10：启动关闭视觉导航程序：Startvisual()

1. 将临时生成的 UUID 赋值给变量 uuid；
2. 将生成的 UUID 传递给 ROS Launch 日志记录系统；
3. 使用 launchgo 这个变量来标识 `/home/nvidia/catkin_ws/src/mower_ctrl/lining_visual.launch` 文件；
4. 使用 launchgo 的 start() 方法来启动该文件；
5. 终端打印日志：`go visual started`



###### 方法11：MainLoop()

1. 如果节点未关闭：

	1. 如果类中变量 rx_command_num 的值为 1：
		1. rx_command_num 的值设为0；
		2. 检测摄像头是否正常连接：
			1. cap 获取路径：`/dev/video-mid` 中的视频；
				1. 如果打开失败
					1. 终端打印：camera is error
					2. 调用方法TxCommand()，传入参数 1： 
						1. 终端打印：`tx command num:`
						2. 终端打印：`num` 的值；
						3. 类中变量 tx_command 的值设为 num；
						4. 使用发布者 tx_command_publisher 发布类中变量 tx_command 的值。
				2. 不满足上述情况：
					1. 终端打印：camera is conntect
					2. 释放 cap 资源；
					3. 调用方法TxCommand()，传入参数 2： 
						1. 终端打印：`tx command num:`
						2. 终端打印：`num` 的值；
						3. 类中变量 tx_command 的值设为 num；
						4. 使用发布者 tx_command_publisher 发布类中变量 tx_command 的值。
					4. 设置类中变量 autoflag 的值为 1；
					5. 调用 Startvisual() 方法：
						1. 将临时生成的 UUID 赋值给变量 uuid；
						2. 将生成的 UUID 传递给 ROS Launch 日志记录系统；
						3. 使用 launchgo 这个变量来标识 `/home/nvidia/catkin_ws/src/mower_ctrl/lining_visual.launch` 文件；
						4. 使用 launchgo 的 start() 方法来启动该文件；
						5. 终端打印日志：`go visual started`
	2. 如果类中变量 rx_command_num 的值为 3 并且类中变量 autoflag 的值为 1：
		1. 类中变量 rx_command_num 的值设为 0；
		2. 关闭 launchgo 对应的节点；
		3. 类中变量 timeout_cnt 的值设为类中变量 timeout；
		4. 类中变量 autoflag  的值设为 0；
		5. 类中变量 lining_flag 的值设为 `LiningState.WAITING`；
		6. 类中变量 distance 的值设为 0；
		7. 类中变量 mode_change_value 的值设为 0；
		8. 类中变量 switch_time 的值设为 当前时间戳；
		9. 对象PD_controller 调用方法 Clear()：
			1. 类中列表变量 error 的值设为 `[0, 0, 0]`；
			2. 类中变量 feedback 的值设为传入参数 0；
			3. 类中变量 reference 的值设为传入参数 0；
		10. 终端打印：`launch stop OK`
	3. 如果类中变量 autoflag 的值为 1 ：
		1. 调用 ControlOnce() 方法
	4. ros 休眠

	



# 2、launch文件

## 1、hf.launch

1. 设置 `~control_rate` 的值为 10；

2. 启动 mower_ctrl 功能包的 hfflower.py 文件：

	参数 `~control_rate` 设置为 10；

	参数 ==`~linear_yk`== 设置为 0.75；

	参数 ==`~linear_zk`== 设置为 0.25；

	参数 ==`~linear_allk`== 设置为 0.5；

	参数 ==`~near_ul`== 设置为 1500；

	参数 ==`~far_ul`== 设置为 2000。

3. 启动 mower_ctrl 功能包的 hfserial.py 文件：

	参数 `~control_rate` 设置为 10；



## 2、mower_ctrl.launch

1. 启动功能包 joy 的类型  **joy_node**，节点名为 **joy_node**，

	`~autorepeat_rate` 的值设为 10；

2. 启动功能包 **mower_ctrl** 的 **motion_ctrl.py** 文件，节点名为：**motion_ctrl**：

	设置参数 `~control_rate` 为 外部参数`~control_rate` 的值；

3. 启动功能包 mower_ctrl 的  joystick_ctrl.py 文件，节点名为：joystick_ctrl：

	设置参数 `~speed_range` 为 0.5；

	设置参数 `~angle_range` 为1.0；




## 3、lining_ctrl.launch

1. 设置 `~control_rate` 的值为 10；

2. 启动功能包 **mower_ctrl**  的 **motion_ctrl.py** 文件，节点名为：**motion_ctrl**：

	设置参数 `~control_rate` 为 外部参数 `~control_rate`  的值；

3. 启动功能包 **mower_ctrl**  的 **lining_ctrl.py** 文件，节点名为：**lining_ctrl**：

	设置参数 `~d_weight` 的值为 1；

	设置参数 `~kp` 的值为 `-0.5`；

	设置参数 `~kd` 的值为 `-13.3`；

	设置参数 `~lining_speed` 的值为 1；

	设置参数 `~control_rate` 的值为 `$(arg ~control_rate)`，即：值为 10；

	

## 4、gps_ctrl.launch

1. 设置 `~control_rate` 的值为 10；

2. 启动功能包 **mower_ctrl**  的 **motion_ctrl.py** 文件，节点名为：**motion_ctrl**：

	设置参数 `~control_rate` 为 外部参数`~control_rate` 的值；

3. 启动功能包 **mower_ctrl**  的 **BYGPS_reader.py** 文件，节点名为：**BYGPS_reader**：

	设置参数 `~control_rate` 为 外部参数`~control_rate` 的值；

4. 启动功能包 **mower_ctrl** 的 **local_xy_nav.py** 文件，节点名为：**local_xy_nav**：

	设置参数 `~kp` 为 `-0.5`；

	设置参数 `~kd` 为 `-13.3`；

	设置参数 `~lining_speed` 为 `1`；

	设置参数 `~control_rate` 为外部参数`~control_rate` 的值；

	设置参数 `~land_long` 为 `8`；

	设置参数 `~land_wide` 为 `4`；

	设置参数 `~scan_wide` 为 `2`；

	

	

	

 
