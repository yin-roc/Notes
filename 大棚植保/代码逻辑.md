# 1、mower_ctrl 功能包

## 1、heserial.py（串口文件）

### 1.1、涉及自定义消息类型

#### 1.1.1	CtrlComand.msg

行驶速度和转向角度：

```
float32 driving_speed
float32 steering_angle
```



#### 1.1.2	ModeSwitch.msg

目标模式：行驶、转换、旋转

```
uint8 target_mode
uint8 MOTION_MODE_STEERING = 0
uint8 MOTION_MODE_TRANSLATION = 1
uint8 MOTION_MODE_ROTATION = 2
```



#### 1.1.3	SensorValue.msg

传感器的值：==具体含义未知==

```
uint8 col_data1
uint8 col_data2
uint8 col_data3
uint8 col_data4
uint16 ul_data1
uint16 ul_data2
uint16 ul_data3
uint16 ul_data4
uint32 distance
uint8 carpipe
uint8 rollpipe
float32 nowcar_speed
```



### 1.2、程序解析

#### 1.2.1	类

##### 类1：AUTOState（枚举类）

共计四个状态：WAITING（等待）、ALIGNMENT（对齐）、WORK（工作）、START（启动）

```c++
class AUTOState(Enum):
    WAITING = 0       
    ALIGNMENT = 1
    WORK = 2
    START = 3
```



##### 类2：串口控制

###### 方法1：初始化函数

1. 初始化节点名：`hf_serial`，并设置无论如何启动该节点；

2. 初始化串口名称（serial_port， "/dev/ttyTHS1"）、波特率（serial_baudrate，115200）、控制速率或控制频率（control_rate）、ros循环频率（rate，由前者 control_rate 传入）；

3. 初始化时间（==time==）为0；

4. 初始化计数（==ctrl_count_down==）为0；

5. 定义发送指令集（tx_command）

	包括：摄像头未被正确检测、上位机自检无误、设置运动模式为横向、设置运动模式为竖向、上位机对行完成、上位机对行错误、获取当前车辆各模块各状态数据信息、通知上位机开始工作、通知下位机里程计清零、通知上位机退出自动工作、通知上位机暂停工作、通知上位机继续自动工作：

	```c++
	self.tx_command = [
	            "#camera,ERROR*\n", 
	            "#jeston_check,OK*\n", 
	            "set_mode TS\n",
	            "set_mode VT\n",
	            "alignment_ready\n",
	            "alignment_error\n",
	            "read_carinfo\n",
	            "#work_start,OK*\n",
	            "distance_reset\n",
	            "#work_stop,OK*\n",
	            "#work_warning,OK*\n",
	            "#work_continue,OK*\n"
	            ]
	```

6. 初始化传输计数（tx_count）、传输数量（tx_num）、命令行界面时间（CLItime）均为0；

7. 初始化当前工作模式为 start，即开始自动工作；

8. 串口初始化操作，定义串口变量ser，定义串口地址；（serial_port）、波特率（serial_baudrate）以及发送或等待数据的超时时间（timeout=0.5/self.control_rate）；若设置不成功则打印错误信息；

9. 定义发布者：

	1）RX_num_publisher：发送 Int8 类型消息，话题名为 “RX_num”；

	2）RX_info_publisher：发送自定义消息类型为 SensorValue 的消息，话题名为“RX_info”；

	3）carinfo_publisher：发送 string 类型的消息，话题名为“car_info”；

	

10. 定义订阅者：

	1. TX_num_subscriber：订阅话题名为“TX_num”，消息类型为 Int8 的消息，回调函数为 TXHandler ；

		回调函数：

		1. 接收 Int8 消息类型的变量为 ==tx_num==；
		2. 如果 ==类中变量tx_num== 为 新传入的 ==tx_num== 值：
			1. ==类中变量tx_num== 为 新传入的 ==tx_num== 值
			2. ==tx_count== 计数置零；
		3. 当接收到的 ==  == 大于 0 且计数（==tx_count==）为 0 时：
			1. 日志记录：tx_command[tx_num.data-1] 的内容；
			2. 并将 tx_command 字符串集中 ==tx_num== 对应的数据写入串口；
			3. ==CLItime== 设为9，==tx_count== 计数自加1；
		4. 当计数 ==tx_count==  为 3 时，清零。

	2. ctrl_subscriber：订阅话题名为“ctrl_command”，消息类型为自定义消息类型：CtrlCommand，调用回调函数为 CtrlCommandHandler：

		回调函数：

		1. 接收 CtrlCommand 消息类型的变量为 ==ctrl_msg==；
		2. 如果当前 ctrl_count_down 为 0 且当前车辆状态为 自动工作：
			1. 设置 driving_speed 为 ctrl_msg 中 driving_speed  四舍五入且保留两位小数的结果；
			2. 设置 steering_angle为 ctrl_msg 中 steering_angle 四舍五入且保留两位小数的结果；
			3. 初始化字符串 ctrl_command_str 的内容为 “move <speed> <angle>\n”;
			4. 打印字符串 ctrl_command_str  内容，并写入到串口；
			5. 设置 ==CLItime== 为 9， self.==ctrl_count_down== 为 1。

11. 初始化以下参数

	```python
	self.last_speed = 0
	self.last_angle = 0
	self.last_rspeed = 0
	self.last_wateren = 0
	self.driving_speed = 0
	self.steering_angle = 0
	self.roll_speed = 0
	self.water_en = 0
	```



###### 方法2：析构函数 del

对象销毁前关闭串口



###### 方法3：命令接收函数 TXHandler（参数：tx_num，参数类型：Int8 ）

1. 接收 Int8 消息类型的变量为 ==tx_num==；
2. 如果 ==类中变量tx_num== 为 新传入的 ==tx_num== 值：
	1. ==类中变量tx_num== 为 新传入的 ==tx_num== 值
	2. ==tx_count== 计数置零；
3. 当接收到的 ==  == 大于 0 且计数（==tx_count==）为 0 时：
	1. 日志记录：tx_command[tx_num.data-1] 的内容；
	2. 并将 tx_command 字符串集中 ==tx_num== 对应的数据写入串口；
	3. ==CLItime== 设为9，==tx_count== 计数自加1；
4. 当计数 ==tx_count==  为 3 时，清零。



###### 方法4：命令接收函数 CtrlCommandHandler（参数：ctrl_msg，参数类型：CtrlCommand ）

1. 接收 CtrlCommand 消息类型的变量为 ==ctrl_msg==；
2. 如果当前 ctrl_count_down 为 0 且当前车辆状态为 自动工作：
	1. 设置 driving_speed 为 ctrl_msg 中 driving_speed  四舍五入且保留两位小数的结果；
	2. 设置 steering_angle为 ctrl_msg 中 steering_angle 四舍五入且保留两位小数的结果；
	3. 初始化字符串 ctrl_command_str 的内容为 “move <speed> <angle>\n”;
	4. 打印字符串 ctrl_command_str  内容，并写入到串口；
	5. 设置 ==CLItime== 为 9， self.==ctrl_count_down== 为 1。

###### 方法5：命令接收函数 RxCommand

1. 接收参数：==num==（类型未知）

2. 打印当前接收到的消息；

3. 初始化 RX_num 内容为 num；

4. 发布者RX_num_publisher 发布 RX_num 。




###### 方法6：==空闲指令函数== FreeCLITxCommand 

1. 如果 CLItime 大于 0 ，则自减 1；
2. 否则：
	1. 发送空闲指令 free_command，内容为“CLI_free\n”；
	2. 日志记录空闲指令内容；
	3. 串口写入空闲指令 free_command；
	4. CLItime 置 9。



###### 方法7：主循环 MainLoop

运行前提：ros正在运行

1. 打印当前工作状态；
2. 读取串口信息并存入 feedback 中；
3. 当当前状态为 AUTOState.START （开始工作）时：
	1. 设置 start_command 内容为：`program_started\n` ；
	2. 日志记录 start_command 的内容；
	3. 并在串口写入该信息，通知下位机：上位机已经准备就绪；CLItime 置 9 ；
	4. 当从串口读入的信息 （feedback）长度大于 1：
		1. 终端打印：`RX: + 接收到的内容`；
		2. 如果读取出来的信息为 `#program_started,OK*\n`，表示通知下位机：上位机决策程序正常启动；
		3. 将当前状态设为等待（AUTOState.WAITING）
4. 当当前状态为等待（AUTOState.WAITING）：
	1. 如果接受到的串口信息数据长度大于 1：
		1. 终端打印：`RX：+ 接收到的内容(feedback)`；
		2. 如果接受到的信息刚好为：`auto_work\n`（表示下位机通知上位机：进入自动工作模式）：
			1. 通过 RxCommand 函数调用发布者 RX_num_publisher 发布 1（num的值），当前状态设置为 对齐；
5. 当当前状态为对齐（AUTOState.ALIGNMENT）：
	1. 如果从串口接收到的信息长度大于 1：
		1. 打印：`RX：+ 接收到的内容`；
		2. 如果从串口读取的信息为：`work_start\n`，（表示下位机通知上位机：开始自动工作）：
			1. 通过 RxCommand 函数调用发布者 RX_num_publisher 发布 2（num的值）；
			2. 将当前状态设置为 自动工作（AUTOState.WORK）；
		3. 如果从串口读取的信息为：`work_stop\n`，（表示下位机通知上位机：退出自动工作）：
			1. 通过 RxCommand 函数调用发布者 RX_num_publisher 发布 3（num的值）；
			2. 将当前状态设置为 等待（AUTOState.WAITING）；
6. 当当前状态为自动工作（AUTOState.WORK）：
	1. 如果接受到的串口信息数据长度大于 1：
		1. 终端打印：`RX：+ 接收到的内容`；
		2. 如果从串口读取的信息为：`work_stop\n`（表示下位机通知上位机：退出自动工作）：
			1. 通过 RxCommand 函数调用发布者 RX_num_publisher 发布 3（num的值）；
			2. 将当前状态设置为 等待（AUTOState.WAITING）；
			3. ctrl_count_down 计数清零；
		3. 如果从串口读取的信息为：`#set_mode,OK*\n`（表示下位机通知上位机：运动模式设置成功）：
			1. 通过 RxCommand 函数调用发布者 RX_num_publisher 发布 4（num的值）；
		4. 如果从串口读取的信息为：`#distance_reset,OK*\n`（表示下位机通知上位机：里程计清零成功）：
			1. 通过 RxCommand 函数调用发布者 RX_num_publisher 发布 5（num的值）；
		5. 如果上述情况都不满足：
			1. 对从串口读取的数据进行处理：先使用 `*` 作为分隔符，并取拆分后的第一段，再对其使用分隔符 `,` 进行处理；
			2. 将经过两次拆分的字符串列表赋值给 RX_STR；
			3. 如果拆分后的第一段内容等于 `#move` && 拆分后的第二段内容等于 `OK`  && 字符串列表的长度为 6：
				1. 将拆分后的第三段内容保留两位小数后，赋值给 last_speed；
				2. 将拆分后的第四段内容保留两位小数后，赋值给 last_angle；
				3. 将拆分后的第五段内容保留整数部分后，赋值给 RX_info（自定义消息类型SensorValue）的 ul_data1；
				4. 将拆分后的第六段内容保留整数部分后，赋值给 RX_info（自定义消息类型SensorValue）的 ul_data2；
				5. 调用发布者 RX_info_publisher 发布 RX_info 信息（RX_info）；
				6. 如果 last_speed 等于 driving_speed && last_angle 等于 steering_angle，打印：`move feedback ok`，并将 ctrl_count_down 清零。
			4. 拆分后的第一段内容等于 `#read_carinfo` && 拆分后的第二段内容等于 `OK`  && 字符串列表的长度为 44：
				1. 将从串口读取的信息存入 carinfo，并使用发布者 carinfo_publisher 发布该信息（carinfo）；
				2. 将拆分后的第18段内容保留整数部分后，赋值给 RX_info（自定义消息类型SensorValue）的 col_data1；
				3. 将拆分后的第19段内容保留整数部分后，赋值给 RX_info（自定义消息类型SensorValue）的 col_data2；
				4. 将拆分后的第20段内容保留整数部分后，赋值给 RX_info（自定义消息类型SensorValue）的 col_data3；
				5. 将拆分后的第21段内容保留整数部分后，赋值给 RX_info（自定义消息类型SensorValue）的 col_data4；
				6. 将拆分后的第14段内容保留整数部分后，赋值给 RX_info（自定义消息类型SensorValue）的 ul_data1；
				7. 将拆分后的第15段内容保留整数部分后，赋值给 RX_info（自定义消息类型SensorValue）的 ul_data2；
				8. 将拆分后的第16段内容保留整数部分后，赋值给 RX_info（自定义消息类型SensorValue）的 ul_data3；
				9. 将拆分后的第17段内容保留整数部分后，赋值给 RX_info（自定义消息类型SensorValue）的 ul_data4；
				10. 将拆分后的第22段内容保留整数部分后，赋值给 RX_info（自定义消息类型SensorValue）的 distance；
				11. 使用发布者 RX_info_publisher发布该信息（RX_info）
7. 执行空闲指令函数
8. 按照设定频率 rate 循环



## 2、hfflower.py

### 1、涉及的自定义消息类型

#### 1.1	CtrlComand.msg

行驶速度和转向角度：

```
float32 driving_speed
float32 steering_angle
```



#### 1.2	ModeSwitch.msg

目标模式：行驶、转换、旋转

```
uint8 target_mode
uint8 MOTION_MODE_STEERING = 0
uint8 MOTION_MODE_TRANSLATION = 1
uint8 MOTION_MODE_ROTATION = 2
```



#### 1.3	SensorValue.msg

传感器的值：==具体含义未知==

```
uint8 col_data1
uint8 col_data2
uint8 col_data3
uint8 col_data4
uint16 ul_data1
uint16 ul_data2
uint16 ul_data3
uint16 ul_data4
uint32 distance
uint8 carpipe
uint8 rollpipe
float32 nowcar_speed
```



### 2	程序解析

#### 2.1	类

##### 类1：WHEEL（枚举类）

横向（TRANSVERSE）和垂直（VERTICAL）

```cpp
class WHEEL(Enum):
    TRANSVERSE =0
    VERTICAL =1
```



##### 类2：CarTowards（枚举类）

GO（前进）和BACK（后退）

```cpp
class CarTowards(Enum):
    GO =0
    BACK =1
```



##### 类3：AUTOState（枚举类）

在 heserial.py 文件的枚举类 AUTOState 基础上加了 FINISH（结束）==、OVER（）和	ERROR（）==

```cpp
class AUTOState(Enum):
    WAITING = 0       
    ALIGNMENT = 1
    GOWORK = 2
    BACKWORK = 3
    FINISH = 4
    OVER = 5
    ERROR = 6
```



##### 类4：decision（决策）

###### 方法1：初始化函数（init）

1. 初始化节点：hf_decision；

2. 通过外部参数 control_rate 初始化 control_rate，默认为 10；

3. 通过外部参数 ==linear_yk== 初始化 linear_yk，默认为 0.75；

4. 通过外部参数 ==linear_zk== 初始化 linear_zk，默认为 0.25；

5. 通过外部参数 ==linear_allk==初始化 linear_allk，默认为 0.5；

6. 通过外部参数 ==near_ul==初始化 near_ul，默认为 800；

7. 通过外部参数 ==far_ul==初始化 far_ul，默认为 1200；

8. 定义一个 ROS 频率控制器对象，值为 control_rate；

9. 当前机器人的状态由 current_state 存储并初始化为 AUTOState.WAITING；

10. 初始化参数 distance 为 0；

11. 初始化参数 last_distance 为 0；

12. 初始化参数 dis_reset_flag 为 0；

13. 初始化参数 nav_num 为 0；

14. 初始化参数 nav_num1 为 0；

15. 初始化参数 delta_d 为 0；

16. 初始化参数 delta_d1为 0；

17. 初始化参数 speed 为 0；

18. 初始化参数 rx_num 为 0；

19. 初始化参数 setmodenum 为 0；

20. 初始化当前视觉对行情况标志位 leftflag 为 0；

21. 初始化当前视觉对行情况标志位 rightflag 为 0；

22. 初始化当前视觉对行情况标志位 leftnum 为 0；

23. 初始化当前视觉对行情况标志位 rightnum 为 0；

24. 初始化当前各传感器数值 ul_num1 为 0；

25. 初始化当前各传感器数值 ul_num2 为 0；

26. 初始化当前各传感器数值 ul_overtime 为 0；

27. 定义发布者：

	1. TX_num_publisher：发送 Int8 类型消息，话题名为 “TX_num”；
	2. ctrl_publisher：发送自定义 CtrlCommand 类型消息，话题名为 “ctrl_command”；

28. 定义订阅者：

	1. twist_subscriber：订阅话题名为 `duihang`，消息类型为 Twist 的消息，回调函数为 NavigationHandler；

		回调函数：

		1. 接收 Twist 消息类型的变量为 twist_msg；
		2. 类中变量 nav_num 数值加1；
		3. 类中变量 leftnum 数值等于 5；
		4. 如果类中的变量 标志位 ==leftflag== 小于 2：
			1. 如果接收到的 twist_msg 的 x 方向上的线速度不等于 0：
				1. ==leftflag== 置 1；
				2. delta_d 的变量赋值 `(twist_msg.linear.y * self.linear_yk + twist_msg.linear.z * self.linear_zk) * self.linear_allk`；
			2. 如果接收到的 twist_msg 的 x 方向上的线速度等于 0：
				1. ​	==leftflag== 置零。

	2. twist_subscriber2：订阅话题名为 `duihang2`，消息类型为 Twist 的消息，回调函数为 NavigationHandler2；

		回调函数：

		1. 接收 Twist 消息类型的变量为 twist_msg；

		2. 类中变量 nav_num1 数值加1；

		3. 类中变量 rightnum 数值等于 5；

		4. 如果接收到的 twist_msg 的 x 方向上的线速度不等于 0：

			1. ==rightflag== 置 1；
			2. delta_d 的变量赋值 `(twist_msg.linear.y * self.linear_yk + twist_msg.linear.z * self.linear_zk) * self.linear_allk`；
	
			1. 如果接收到的 twist_msg 的 x 方向上的线速度等于 0：
				1. ​	==rightflag== 置零。

	3. twist_subscriber3：订阅话题名为 `duihang3`，消息类型为 Twist 的消息，回调函数为 NavigationHandler3；

		回调函数：

		1. 接收 Twist 消息类型的变量为 twist_msg；
		2. 类中变量 nav_num 数值加1；
		3. 类中变量 leftnum 数值等于 5；
		4. 如果类中的变量 标志位 ==leftflag== 小于 2：
			1. 如果接收到的 twist_msg 的 x 方向上的线速度不等于 0：
				1. ==leftflag== 置 1；
				2. delta_d 的变量赋值 `(twist_msg.linear.y * self.linear_yk + twist_msg.linear.z * self.linear_zk) * self.linear_allk`；
			2. 如果接收到的 twist_msg 的 x 方向上的线速度等于 0：
				1. ​	==leftflag== 置零。

	4. twist_subscriber4：订阅话题名为 `duihang4`，消息类型为 Twist 的消息，回调函数为 NavigationHandler4；

		回调函数：

		1. 接收 Twist 消息类型的变量为 twist_msg；

		2. 类中变量 nav_num1 数值加1；

		3. 类中变量 rightnum 数值等于 5；

		4. 如果接收到的 twist_msg 的 x 方向上的线速度不等于 0：

			1. ==rightflag== 置 1；
			2. delta_d 的变量赋值 `(twist_msg.linear.y * self.linear_yk + twist_msg.linear.z * self.linear_zk) * self.linear_allk`；
	
			1. 如果接收到的 twist_msg 的 x 方向上的线速度等于 0：
				1. ​	==rightflag== 置零。

	5. RX_num_subscriber：订阅话题名为 `RX_num`，消息类型为 Int8 的消息，回调函数为 RXHandler（==接收串口信号数值==）；

		回调函数：

		1. 接收 Int8 消息类型的变量为 rx_num；

		2. 类中变量 ==rx_num== 数值为订阅到的消息 rx_num 中的 data 部分；

		3. 在终端打印：rx_num 的值；

		4. 如果类中的 rx_num 等于 3：

			1. 类中的 rx_num 清零；

			2. 如果类中的 launch_state 为 AUTOState.GOWORK：

				1. 终止 launchgo 对应的节点；

			3. 如果类中的 launch_state 为 AUTOState.BACKWORK：

				1. 终止 launchback 对应的节点；

			4. 调用 StopToWaitInit() 函数，初始化以下参数：

				​						nav_num = 0；

				​						nav_num1 = 0；

				​						leftflag = 0；

				​						rightflag = 0；

				​						leftnum = 0；

				​						rightnum = 0；

				​						setmodenum = 0；

				​						distance = 0；

				​						dis_reset_flag = 0；

				​						delta_d = 0；

				​						delta_d1 = 0；

				​						speed = 0；

				​						rx_num = 0；

			5. 调用 TxCommand() 函数（命令发送）并传入参数 10：

				1. 打印日志：tx command num: 10；
				2. 将类中的变量 TX_num 初始化为 num（10）；
				3. 调用发布者 TX_num_publisher 发布 TX_num；

			6. 将当前状态 current_state 设为 AUTOState.WAITING：

		5. 如果当前类中的 rx_num 等于 4：

			1. 将类中的 setmodenum 设为 1；

		6. 如果当前类中的 rx_num 等于 5：

			1. 将类中的 dis_reset_flag 设为 1；	

	6. RX_info_subscriber：订阅话题名为 `RX_info`，消息类型为 SensorValue 的消息，回调函数为 InfoHandler（==接收各传感器数值并处理==）：

		回调函数：

		1. 接收 SensorValue 消息类型的变量为 msg；
		2. 类中变量 ==ul_num1== 为订阅的 msg 中的 ul_data1；
		3. 类中变量 ==ul_num2== 为订阅的 msg 中的 ul_data2；

		

###### 方法2：启动关闭视觉导航程序（Startvisual）

1. 将临时生成的 UUID 赋值给变量 uuid；
2. 将生成的 UUID 传递给 ROS Launch 日志记录系统；
3. 如果接收到的 cartowards 内容为 CarTowards.GO：
	1. 使用 launchgo 这个变量来标识 hfvisual_go.launch 文件；
	2. 使用 launchgo 的 start() 方法来启动该文件；
	3. 将 launch_state 状态设置为 AUTOState.GOWORK；
	4. 终端打印日志：`go visual started`
4. 如果接收到的 cartowards 内容为 CarTowards.BACK：
	1. 使用 launchback 这个变量来标识 hfvisual_back.launch 文件；
	2. 使用 launchback 的 start() 方法来启动该文件；
	3. 将 launch_state 状态设置为 AUTOState.BACKWORK；
	4. 终端打印日志：`back visual started`。

​		

###### 方法3：RXHandler()（参数：rx_num，参数类型：Int8 ）

1. 接收 Int8 消息类型的变量为 rx_num；

2. 类中变量 ==rx_num== 数值为订阅到的消息 rx_num 中的 data 部分；

3. 在终端打印：rx_num 的值；

4. 如果类中的 rx_num 等于 3：

	1. 类中的 rx_num 清零；

	2. 如果类中的 launch_state 为 AUTOState.GOWORK：

		1. 终止 launchgo 对应的节点；

	3. 如果类中的 launch_state 为 AUTOState.BACKWORK：

		1. 终止 launchback 对应的节点；

	4. 调用 StopToWaitInit() 函数，初始化以下参数：

		​						nav_num = 0；

		​						nav_num1 = 0；

		​						leftflag = 0；

		​						rightflag = 0；

		​						leftnum = 0；

		​						rightnum = 0；

		​						setmodenum = 0；

		​						distance = 0；

		​						dis_reset_flag = 0；

		​						delta_d = 0；

		​						delta_d1 = 0；

		​						speed = 0；

		​						rx_num = 0；

	5. 调用 TxCommand() 函数（命令发送）并传入参数 10：

		1. 打印日志：tx command num: 10；
		2. 将类中的变量 TX_num 初始化为 num（10）；
		3. 调用发布者 TX_num_publisher 发布 TX_num；

	6. 将当前状态 current_state 设为 AUTOState.WAITING：

5. 如果当前类中的 rx_num 等于 4：

	1. 将类中的 setmodenum 设为 1；

6. 如果当前类中的 rx_num 等于 5：

	1. 将类中的 dis_reset_flag 设为 1；	



###### 方法4：接收各传感器数值并处理： InfoHandler()（参数：msg，参数类型：SensorValue ）

1. 接收 SensorValue 消息类型的变量为 msg；
2. 类中变量 ==ul_num1== 为订阅的 msg 中的 ul_data1；
3. 类中变量 ==ul_num2== 为订阅的 msg 中的 ul_data2；



###### 方法5：接收视觉程序topic信息：NavigationHandler（参数：twist_msg，参数类型：）

1. 接收 Twist 消息类型的变量为 twist_msg；
2. 类中变量 nav_num 数值加1；
3. 类中变量 leftnum 数值等于 5；
4. 如果类中的变量 标志位 ==leftflag== 小于 2：
	1. 如果接收到的 twist_msg 的 x 方向上的线速度不等于 0：
		1. ==leftflag== 置 1；
		2. delta_d 的变量赋值 `(twist_msg.linear.y * self.linear_yk + twist_msg.linear.z * self.linear_zk) * self.linear_allk`；
	2. 如果接收到的 twist_msg 的 x 方向上的线速度等于 0：
		1. ​	==leftflag== 置零



###### 方法6：接收视觉程序topic信息：NavigationHandler2（参数：twist_msg，参数类型：）

1. 接收 Twist 消息类型的变量为 twist_msg；

2. 类中变量 nav_num1 数值加1；

3. 类中变量 rightnum 数值等于 5；

4. 如果接收到的 twist_msg 的 x 方向上的线速度不等于 0：

	1. ==rightflag== 置 1；
	2. delta_d 的变量赋值 `(twist_msg.linear.y * self.linear_yk + twist_msg.linear.z * self.linear_zk) * self.linear_allk`；

	1. 如果接收到的 twist_msg 的 x 方向上的线速度等于 0：
		1. ​	==rightflag== 置零。



###### 方法7：接收视觉程序topic信息：NavigationHandler3（参数：twist_msg，参数类型：）

1. 接收 Twist 消息类型的变量为 twist_msg；
2. 类中变量 nav_num 数值加1；
3. 类中变量 leftnum 数值等于 5；
4. 如果类中的变量 标志位 ==leftflag== 小于 2：
	1. 如果接收到的 twist_msg 的 x 方向上的线速度不等于 0：
		1. ==leftflag== 置 1；
		2. delta_d 的变量赋值 `(twist_msg.linear.y * self.linear_yk + twist_msg.linear.z * self.linear_zk) * self.linear_allk`；
	2. 如果接收到的 twist_msg 的 x 方向上的线速度等于 0：
		1. ​	==leftflag== 置零。



###### 方法8：接收视觉程序topic信息：NavigationHandler4（参数：twist_msg，参数类型：）

1. 接收 Twist 消息类型的变量为 twist_msg；

2. 类中变量 nav_num1 数值加1；

3. 类中变量 rightnum 数值等于 5；

4. 如果接收到的 twist_msg 的 x 方向上的线速度不等于 0：

	1. ==rightflag== 置 1；
	2. delta_d 的变量赋值 `(twist_msg.linear.y * self.linear_yk + twist_msg.linear.z * self.linear_zk) * self.linear_allk`；

	1. 如果接收到的 twist_msg 的 x 方向上的线速度等于 0：
		1. ​	==rightflag== 置零。



###### 方法9：车辆运动控制（MoveCtrl）

1. 将订阅到的 speed 消息 赋值给类中变量 ctrl_command 的 driving_speed 分量；
2. 将订阅到的 angle 消息 赋值给类中变量 ctrl_command 的 steering_angle 分量；
3. 使用发布者 （ctrl_publisher） 发布 类中变量 ctrl_command；
4. 在终端打印：move 和 类中变量 ctrl_command 的 driving_speed 分量。



###### 方法10：车辆模式切换（Setmode）

1. 如果接受订阅消息的 mode 为 WHEEL.TRANSVERSE：
	1. 调用 TxCommand 方法，传入参数 3，即：
		1. 终端打印日志：tx command num: 3；
		2. 类中变量 TX_num 赋值为 3，并通过发布者 TX_num_publisher 发布 TX_num。 
2. 如果接受订阅消息的 mode 为 WHEEL.VERTICAL：
	1. 调用 TxCommand 方法，传入参数 4，即：
		1. 终端打印日志：tx command num: 4；
		2. 类中变量 TX_num 赋值为 4，并通过发布者 TX_num_publisher 发布 TX_num。



###### 方法11：前进时的车辆速度决策处理（SpeedGoHandler）

1. 如果当前的 leftnum 大于等于 0：

	1. leftnum 做自减1操作；

2. 如果当前的 leftnum 小于 0：

	1. leftflag 置零；

3. 如果当前的 rightnum大于等于 0：

	1. rightnum做自减1操作；

4. 不满足上述情况：

	1. 类中变量 rightflag 置零；
	2. 终端打印：leftflag；
	3. 终端打印：rightflag；
	4. 如果类中变量 nav_num < 150 或者 类中变量 nav_num1 < 150 ，并且 类中变量 leftflag 和 类中变量 rightflag 均等于 0：
		1. 类中变量 ul_overtime 置 0；
		2. 类中变量 speed 取 1；
		3. 类中变量 delta_d 置 0.0；
	5. 如果类中变量 leftflag 等于 1并且 类中变量 rightflag 等于 1：
		1. 类中变量 ul_overtime 置0；
		2. 类中变量 speed 取1；
		3. 类中变量 delta_d 取 类中变量 delta_d 和类中变量 delta_d1的一半值；
	6. 如果类中变量 leftflag 等于 1并且 类中变量 rightflag 等于 0：
		1. 类中变量 ul_overtime 置0；
		2. 类中变量 speed 取1；
		3. 类中变量 delta_d 不变 ；
	7. 如果类中变量 leftflag 等于 0 并且 类中变量 rightflag 等于 1：
		1. 类中变量 ul_overtime 置0；
		2. 类中变量 speed 取1；
		3. 类中变量 delta_d 取类中变量 delta_d1；
	8. 如果类中变量 leftflag 等于 0 并且 类中变量 rightflag 等于 0：
		1. 类中变量 speed 置 0；
		2. 类中变量 delta_d 取 0.0；

5. 如果类中变量 speed 为 0，且类中变量 ul_num1 小于等于 类中变量 far_ul 且类中变量 ul_num2 小于等于 类中变量 far_ul ：

	1. 终端打印日志：`now gowork is finish,visual`；
	2. 类中变量 nav_num 置0；
	3. 类中变量 nav_num1置0；
	4. 关闭 launchgo 所对应的 launch 文件；
	5. 调用 Startvisual() 函数并将 CarTowards.BACK 传递给函数参数 cartowards：
		1. 使用 launchback 这个变量来标识 hfvisual_back.launch 文件；
		2. 使用 launchback 的 start() 方法来启动该文件；
		3. 将 launch_state 状态设置为 AUTOState.BACKWORK；
		4. 终端打印日志：`back visual started`。
	6. 类中变量 dis_reset_flag 置 0；
	7. 类中变量 current_state 设为 AUTOState.BACKWORK；

6. 如果类中变量 speed 为 0，且满足（类中变量 ul_num1 大于等于类中变量 far_ul ） 或者 （类中变量 ul_num2 大于类中变量 far_ul ）之一：

	1. 类中变量 speed 设为 1.0；
	2. 类中变量 delta_d 设为 0.0；

7. 类中变量 ul_overtime 自加 1；

8. 如果类中变量 ul_overtime 大于等于 20：

	1. 类中变量 speed 设为 0.0；
	2. 关闭 launchgo 对应节点；
	3. 终端打印日志：now gowork is error；
	4. 类中变量 current_state 设为 AUTOState.ERROR；

9. 如果（类中变量 ul_num1 小于类中变量 near_ul 并且类中变量 ul_num1 大于 10）或者（类中变量 ul_num2 小于类中变量 near_ul 并且类中变量 ul_num2 大于 10）：

	1. 类中变量 speed 等于 0.0；
	2. 类中变量 delta_d 等于 0.0；
	3. 关闭 launchgo 对应节点；
	4. 终端打印日志：now gowork is error；
	5. 类中变量 current_state 设为 AUTOState.ERROR；

10. 调用 MoveCtrl() 函数，将类中变量 speed 和类中变量 delta_d 分别当作函数参数 speed 和 angle 传入：

	1. 将订阅到的 speed 消息 赋值给类中变量 ctrl_command 的 driving_speed 分量；
	2. 将订阅到的 angle 消息 赋值给类中变量 ctrl_command 的 steering_angle 分量；
	3. 使用发布者 （ctrl_publisher） 发布 类中变量 ctrl_command；
	4. 在终端打印：move 和 类中变量 ctrl_command 的 driving_speed 分量。

	​	

###### 方法12：后退时的车辆速度决策处理（SpeedBackHandler）

1. 如果当前的 leftnum 大于等于 0：

	1. leftnum 做自减1操作；

2. 如果当前的 leftnum 小于 0：

	1. leftflag 置零；

3. 如果当前的 rightnum大于等于 0：

	1. rightnum做自减1操作；

4. 不满足上述情况：

	1. rightflag 置零；
	2. 终端打印：leftflag
	3. 终端打印：rightflag

5. 如果类中变量 nav_num < 300 或者 类中变量 nav_num1 < 300，并且 类中变量 leftflag 和 类中变量 rightflag 均等于 0：

	1. 类中变量 ul_overtime 置 0；
	2. 类中变量 speed 取 `-1`；
	3. 类中变量 delta_d 置 0.0；

6. 如果类中变量 leftflag 等于 1并且 类中变量 rightflag 等于 1：

	1. 类中变量 ul_overtime 置 0；
	2. 类中变量 speed 取 `-1`；
	3. 类中变量 delta_d 取 类中变量 delta_d 和类中变量 delta_d1的一半值；

7. 如果类中变量 leftflag 等于 1并且 类中变量 rightflag 等于 0：

	1. 类中变量 ul_overtime 置0；
	2. 类中变量 speed 取 `-1`；
	3. 类中变量 delta_d 不变 ；

8. 如果类中变量 leftflag 等于 0 并且 类中变量 rightflag 等于 1：

	1. 类中变量 ul_overtime 置0；
	2. 类中变量 speed 取 `-1`；
	3. 类中变量 delta_d 取类中变量 delta_d1；

9. 如果类中变量 nav_num 大于等于 300，且类中变量 nav_num1 大于等于300，且类中变量 leftflag 等于 0 并且 类中变量 rightflag 等于 0 且：

	1. 类中变量 speed 设为 0.0；
	2. 类中变量 delta_d 取 0.0；

10. 如果类中变量 speed 为 0，且类中变量 ul_num1 小于等于 类中变量 far_ul 且类中变量 ul_num2 小于等于 类中变量 far_ul ：

	1. 终端打印日志：`now backwork is finish,visual`

	2. 类中变量 nav_num 置0；

	3. 类中变量 nav_num1置0；

	4. 关闭 launchback 所对应的 launch 文件；

	5. 将 launch_state 状态设置为 AUTOState.FINISH；

		​						终端打印日志：`back visual started`。

11. 如果类中变量 speed 为 0.0，且满足（类中变量 ul_num1 大于类中变量 far_ul ） 或者 （类中变量 ul_num2 大于类中变量 far_ul ）之一：

	1. 类中变量 speed 设为 `-1.0`；
	2. 类中变量 delta_d 设为 0.0；

12. 类中变量 ul_overtime 自加1；

13. 如果类中变量 ul_overtime 大于等于 20：

	1. 类中变量 speed 设为 0.0；
	2. 关闭 launchback 对应节点；
	3. 终端打印日志：`now backwork is error`；
	4. 类中变量 current_state 设为 AUTOState.ERROR；

14. 如果（类中变量 ul_num1 小于类中变量 near_ul 并且类中变量 ul_num1 大于 10）或者（类中变量 ul_num2 小于类中变量 near_ul 并且类中变量 ul_num2 大于 10）：

	1. 类中变量 speed 等于 0.0；
	2. 类中变量 delta_d 等于 0.0；
	3. 关闭 launchback 对应节点；
	4. 终端打印日志：now backwork is error；
	5. 类中变量 current_state 设为 AUTOState.ERROR；

15. 调用 MoveCtrl() 函数，将类中变量 speed 和类中变量 `-delta_d` 分别当作函数参数 speed 和 angle 传入：

	1. 将订阅到的 speed 消息 赋值给类中变量 ctrl_command 的 driving_speed 分量；
	2. 将订阅到的 angle 消息 赋值给类中变量 ctrl_command 的 steering_angle 分量；
	3. 使用发布者 （ctrl_publisher） 发布 类中变量 ctrl_command；
	4. 在终端打印：move 和 类中变量 ctrl_command 的 driving_speed 分量。

​		

###### 方法13：StopToWaitInit()

初始化类中变量：

```
nav_num = 0；
nav_num1 = 0；
leftflag = 0；
rightflag = 0；
leftnum = 0；
rightnum = 0；
setmodenum = 0；
distance = 0；
dis_reset_flag = 0；
delta_d = 0；
delta_d1 = 0；
speed = 0；
rx_num = 0
```



###### 方法 14：MainLoop() （主循环参数）

当 ros 节点没有退出：

1. 终端打印日志：current_state（类中变量）

2. 终端打印日志：near_ul（类中变量）；

3. 如果类中变量current_state （当前状态）等于 AUTOState.WAITING：

	如果类中变量 rx_num 等于 1：

	1. 将该变量置0；
	2. 使用 VideoCapture 类来初始化四个视频捕获对象，分别用于从四个不同的视频设备（摄像头）中捕获视频流，四个对象分别为：cap1、cap2、cap3 和 cap4；
	3. 如果有一个摄像头打开失败，终端打印：`camera is error`；
		1. 调用 TxCommand() 函数，传入参数 1：
		2. 终端打印日志：tx command num: 1；
		3. 类中变量 TX_num 赋值为 1，并通过发布者 TX_num_publisher 发布 TX_num。
	4. 如果全部连接成功：
		1. 终端打印日志：`camera is conntect`；
		2. 使用 release 方法释放摄像头资源；
		3. 调用 TxCommand() 函数，传入参数 2：
			1. 终端打印日志：tx command num: 2；
			2. 类中变量 TX_num 赋值为 2，并通过发布者 TX_num_publisher 发布 TX_num。
		4. 调用 Startvisual() 函数，并将 CarTowards.GO 作为参数传递给 cartowards：
			1. 使用 launchgo 这个变量来标识 hfvisual_back.launch 文件；
			2. 使用 launchgo 的 start() 方法来启动该文件；
			3. 将 launch_state 状态设置为 AUTOState.GOWORK；
			4. 终端打印日志：`go visual started`。
		5. 类中变量 current_state 设为 AUTOState.ALIGNMENT；

4. 如果类中变量 current_state （当前状态）等于 AUTOState.ALIGNMENT：

	1. 终端打印日志：`leftflag` 的值；
	2. 终端打印日志：`rightflag` 的值；
	3. 如果类中变量 rx_num 等于 2：
		1. 将该变量置0；
		2. 调用 TxCommand() 函数，传入参数 8：
			1. 终端打印日志：tx command num: 8；
			2. 类中变量 TX_num 赋值为 8，并通过发布者 TX_num_publisher 发布 TX_num。
			3. 类中变量 current_state 设为 `AUTOState.GOWORK`；
	4. 如果类中变量 nav_num 大于 50 且 类中变量 nav_num1 大于 50 且 类中变量 leftflag 等于0 且 类中变量 rightflag 等于0：
		1. 终端打印日志：`TX: alignment_error`；
		2. 调用 TxCommand() 函数，传入参数 6：
			1. 类中变量 TX_num 赋值为 6；
			2. 通过发布者 TX_num_publisher 发布 TX_num。	
	5. 如果类中变量 leftflag 等于 1 且 类中变量 rightflag 等于1：
		1. 终端打印日志：`TX: alignment_ready`；
		2. 调用 TxCommand() 函数，传入参数 5：
			1. 类中变量 TX_num 赋值为 5；
			2. 通过发布者 TX_num_publisher 发布 TX_num。

5. 如果类中变量 current_state （当前状态）等于 AUTOState.GOWORK：

	1. 终端打印日志：`dis_reset_flag`；
	2. 终端打印日志：dis_reset_flag（类中变量的值）；
	3. 如果类中变量 setmodenum 的值为 0：
		1. 调用方法 Setmode 并传入参数WHEEL.VERTICAL：
			1. 调用 TxCommand 方法，传入参数 4，即：
				1. 终端打印日志：tx command num: 4；
				2. 类中变量 TX_num 赋值为 4，并通过发布者 TX_num_publisher 发布 TX_num。
	4. 如果类中变量 setmodenum 的值为 1 且 类中变量 dis_reset_flag 的值为0：
		1. 设置类中变量 roll_speed 为 1；
		2. 设置类中变量 speed 为 1；
		3. 设置类中变量 ul_num1为 0；
		4. 设置类中变量 ul_num2 为 0；
		5. 设置类中变量 distance为 0；		
		6. 调用 TxCommand() 函数，传入参数 9：
			1. 终端打印日志：tx command num: 9；
			2. 类中变量 TX_num 赋值为 9，并通过发布者 TX_num_publisher 发布 TX_num。
	5. 如果类中变量 dis_reset_flag 的值为 1：
		1. 调用函数 SpeedGoHandler()；

6. 如果类中变量 current_state 为 AUTOState.BACKWORK：

	1. 如果类中变量 setmodenum 的值为 1 且 类中变量 dis_reset_flag 的值为0：
		1. 设置类中变量 roll_speed 为 `-1`；
		2. 设置类中变量 speed 为 `-1`；
		3. 设置类中变量 ul_num1为 0；
		4. 设置类中变量 ul_num2 为 0；
		5. 设置类中变量 distance为 0；
		6. 调用 TxCommand() 函数，传入参数 9：
			1. 终端打印日志：tx command num: 9；
			2. 类中变量 TX_num 赋值为 9，并通过发布者 TX_num_publisher 发布 TX_num。
	2. 如果类中变量 dis_reset_flag 的值为 1：
		1. 如果类中变量 nav_num 大于 100 且 类中变量 nav_num1 大于 100：
			1. 调用函数 SpeedBackHandler()
		2. 如果类中变量 current_state 等于 AUTOState.FINISH：
			1. 调用方法 MoveCtrl，并将 speed = 0， angle = 0 当作参数传入：
				1. 将订阅到的 speed 消息 赋值给类中变量 ctrl_command 的 driving_speed 分量；
				2. 将订阅到的 angle 消息 赋值给类中变量 ctrl_command 的 steering_angle 分量；
				3. 使用发布者 （ctrl_publisher） 发布 类中变量 ctrl_command；
				4. 在终端打印：move 和 类中变量 ctrl_command 的 driving_speed 分量。

7. 如果类中变量 current_state 为 AUTOState.ERROR：

	1. 类中变量 nav_num 等于 0；
	2. 类中变量 nav_num1 等于 0；
	3. 调用方法 MoveCtrl，并将 speed = 0， angle = 0 当作参数传入：
		1. 将订阅到的 speed 消息 赋值给类中变量 ctrl_command 的 driving_speed 分量；
		2. 将订阅到的 angle 消息 赋值给类中变量 ctrl_command 的 steering_angle 分量；
		3. 使用发布者 （ctrl_publisher） 发布 类中变量 ctrl_command；
		4. 在终端打印：move 和 类中变量 ctrl_command 的 driving_speed 分量。

8. 终端打印：ul_num1: ul_num1（类中变量的值）；

9. 终端打印：ul_num1: ul_num2（类中变量的值）；

10. 终端打印：ul_num1: ul_overtime（类中变量的值）；

11. 循环休眠；



5. 



## 3、joystick_ctrl.py

### 1、涉及的自定义消息类型

#### 1.1	CtrlComand.msg

行驶速度和转向角度：

```
float32 driving_speed
float32 steering_angle
```



#### 1.2	ModeSwitch.msg

目标模式：行驶、转换、旋转

```
uint8 target_mode
uint8 MOTION_MODE_STEERING = 0
uint8 MOTION_MODE_TRANSLATION = 1
uint8 MOTION_MODE_ROTATION = 2
```



### 2、程序解析

#### 类

##### 类1：JoystickCtrl

###### 方法1：初始化（init）

1. 初始化节点，设为匿名，设置为：joystick_ctrl；

2. 类中列表变量 previous_buttons 设为 [0, 0, 0, 0]；

3. 类中变量 speed_range 从参数服务器中获取 `~speed_range`，默认为 1；

4. 类中变量 angle_range 从参数服务器中获取 `~angle_range`，默认为 1；

5. 创建订阅者：

	1. joystick_subscriber：订阅话题名为“joy”，消息类型为 Joy（sensor_msgs）的消息，回调函数为 JoystickMsgHandler；

		回调函数：

		1. 接收 Joy 消息类型的变量为 joystick_msg；

		2. 尝试：

			1. 将类中变量 ctrl_command 的分量 steering_angle 设为 `-1 * joystick_msg.axes[0] * self.angle_range` 的值；
			2. 将类中变量 ctrl_command 的分量 driving_speed 设为 `joystick_msg.axes[3] * self.speed_range` 的值；
			3. 调用 ctrl_publisher 发布者发布类中变量 ctrl_command 的内容；

		3. 设置失败则日志中记录：`ERROR: fail to control by joystick`

		4. 如果  joystick_msg 的分量 axes[5] 的值转换为 int 后 不等于 0 ：

			1.  如果类中变量  joystick_msg 的分量 buttons[0] 的值等于 1且类中变量 previous_buttons[0] 的值等于 0 ：
				1. 设置类中变量 mode_switch 的分量 target_mode 的值为 ModeSwitch.MOTION_MODE_STEERING；
				2. 调用发布者 mode_publisher 发布类中变量 mode_switch 的值；
			2. 如果类中变量  joystick_msg 的分量 buttons[1] 的值等于 1且类中变量 previous_buttons[1] 的值等于 0 ：
				1. 设置类中变量 mode_switch 的分量 target_mode 的值为 ModeSwitch.MOTION_MODE_TRANSLATION；
				2. 调用发布者 mode_publisher 发布类中变量 mode_switch 的值；
			3. 如果类中变量  joystick_msg 的分量 buttons[2] 的值等于 1且类中变量 previous_buttons[2] 的值等于 0 ：
				1. 设置类中变量 mode_switch 的分量 target_mode 的值为 ModeSwitch.MOTION_MODE_ROTATION；
				2. 调用发布者 mode_publisher 发布类中变量 mode_switch 的值；
			4. 不满足上述条件，不执行任何操作。

		5. 更新类中变量 previous_buttons 中的值：具体为存储当前值为下一步的先前值：

			```python
			self.previous_buttons[0] = int(joystick_msg.buttons[0])
			self.previous_buttons[1] = int(joystick_msg.buttons[1])
			self.previous_buttons[2] = int(joystick_msg.buttons[2])
			```

6. 定义类中变量 ctrl_command 的类型为 CtrlCommand()（自定义消息类型）

7. 定义类中变量 mode_switch 的类型为 ModeSwitch()（自定义消息类型）

8. 创建发布者：

	1. ctrl_publisher：发送 CtrlCommand 类型消息，话题名为 “ctrl_command”；
	2. mode_publisher：发送 ModeSwitch 类型消息，话题名为 “mode_switch”；



###### 方法2：JoystickMsgHandler()

1. 接收 Joy 消息类型的变量为 joystick_msg；

2. 尝试：

	1. 将类中变量 ctrl_command 的分量 steering_angle 设为 `-1 * joystick_msg.axes[0] * self.angle_range` 的值；
	2. 将类中变量 ctrl_command 的分量 driving_speed 设为 `joystick_msg.axes[3] * self.speed_range` 的值；
	3. 调用 ctrl_publisher 发布者发布类中变量 ctrl_command 的内容；

3. 设置失败则日志中记录：`ERROR: fail to control by joystick`

	

	如果  joystick_msg 的分量 axes[5] 的值转换为 int 后 不等于 0 ：

	1.  如果类中变量  joystick_msg 的分量 buttons[0] 的值等于 1且类中变量 previous_buttons[0] 的值等于 0 ：
		1. 设置类中变量 mode_switch 的分量 target_mode 的值为 ModeSwitch.MOTION_MODE_STEERING；
		2. 调用发布者 mode_publisher 发布类中变量 mode_switch 的值；
	2. 如果类中变量  joystick_msg 的分量 buttons[1] 的值等于 1且类中变量 previous_buttons[1] 的值等于 0 ：
		1. 设置类中变量 mode_switch 的分量 target_mode 的值为 ModeSwitch.MOTION_MODE_TRANSLATION；
		2. 调用发布者 mode_publisher 发布类中变量 mode_switch 的值；
	3. 如果类中变量  joystick_msg 的分量 buttons[2] 的值等于 1且类中变量 previous_buttons[2] 的值等于 0 ：
		1. 设置类中变量 mode_switch 的分量 target_mode 的值为 ModeSwitch.MOTION_MODE_ROTATION；
		2. 调用发布者 mode_publisher 发布类中变量 mode_switch 的值；
	4. 不满足上述条件，不执行任何操作。

4. 更新类中变量 previous_buttons 中的值：具体为存储当前值为下一步的先前值：

	```python
	self.previous_buttons[0] = int(joystick_msg.buttons[0])
	self.previous_buttons[1] = int(joystick_msg.buttons[1])
	self.previous_buttons[2] = int(joystick_msg.buttons[2])
	```



###### 3、方法3：MainLoop()

循环



## 4、lining_ctrl_bak.py (路线跟踪)

### 1、涉及的自定义消息类型

#### 1.1	CtrlComand.msg

行驶速度和转向角度：

```
float32 driving_speed
float32 steering_angle
```



#### 1.2	ModeSwitch.msg

目标模式：行驶、转换、旋转

```
uint8 target_mode
uint8 MOTION_MODE_STEERING = 0
uint8 MOTION_MODE_TRANSLATION = 1
uint8 MOTION_MODE_ROTATION = 2
```



### 2、程序解析

#### 类

##### 类1：PDController()

###### 方法1：初始化（init）（参数列表：`kp`，`kd`，`output_max`）

1. 类中变量 kp 的值设为传入参数 kp；
2. 类中变量 kd 的值设为传入参数 kd；
3. 类中变量 output_max 的值设为传入参数 output_max；
4. 类中列表变量 error 的值初始化为 `[0, 0, 0]`；
5. 类中变量 feedback 的值设为 0；
6. 类中变量 reference 的值设为 0；
7. 类中变量 output 的值设为 0；



###### 方法2：Clear()（清零方法）

1. 类中列表变量 error 的值设为 `[0, 0, 0]`；
2. 类中变量 feedback 的值设为传入参数 0；
3. 类中变量 reference 的值设为传入参数 0；



###### 方法3：CalcError()

1. 类中列表变量 error 的第2个参数为列表变量 error 的第1个参数值；
2. 类中列表变量 error 的第1个参数为类中变量 reference 减去类中变量 feedback 的值；



###### 方法4：CalcOutPut()

1. 类中列表变量 output 的值为 `self.error[0] * self.kp + (self.error[0] - self.error[1]) * self.kd`；

	这个公式是**离散时间PID控制器**的一部分。它用来计算PID控制器的输出。具体来说：

	1. self.error[0] 表示当前时刻的误差（偏差）值。
	2. self.error[1] 表示上一个时刻的误差（偏差）值。
	3. self.kp 是比例增益（Proportional gain）。
	4. self.kd 是微分增益（Derivative gain）。
	5. 公式的第一部分 self.error[0] * self.kp 计算了比例控制器的输出，即根据当前误差值计算出的控制量。公式的第二部分 (self.error[0] - self.error[1]) * self.kd 计算了微分控制器的输出，即当前误差值与上一个时刻的误差值之差乘以微分增益。这两部分的和即为PID控制器的输出，用来调节系统以减小误差。

2. 保持类中变量 output 的值始终在区间 `[-output_max, output_max]` 中，超出范围，则设为最接近的区间边界值。



##### 类2： LiningState(枚举类)

```
WAITING = 0         # 等待路线信息
LINING = 1          # 跟随线路
LEAVE = 2           # 离开线路
SWITCHING = 3       # 切换线路
ERROR = 4           # 线路错误
```



##### 类3：LiningController

###### 方法1：初始化（init）

1. 初始化 ros 匿名节点为 lining_ctrl； 

2. 初始化类中变量 d_weight 的值为参数服务器中的 `~d_weight`，未找到设为 1；

3.  初始化类中变量 theta_weight 的值为 `1 - self.d_weight`；

4. 初始化类中变量 kp 的值为参数服务器中的 `~kp` 值，未找到设为 `-0.5`；

5. 初始化类中变量 kd 的值为参数服务器中的 `~kd` 值，未找到设为 `-13.3`；

6. 初始化类中变量 lining_speed 的值为参数服务器中的 `~lining_speed` 值，未找到设为 `1`；

7. 初始化类中变量 control_rate 的值为参数服务器中的 `~control_rate` 值，未找到设为 `10`；

8. 初始化ROS 频率控制器 rate 的值为类中变量 `control_rate` 值；

9. 初始化类中变量 timeout 的值为参数服务器中的 `~timeout` 值 * 1000，未找到设为 `1`；

10. 初始化类中变量 timeout_cnt 的值为类中变量 `timeout` 值； 

11. 初始化类中变量 out_line_time 的值为参数服务器中的 `~out_line_time` 值，未找到设为 `8`；

12. 初始化类中变量 rotation_time 的值为参数服务器中的 `~rotation_time` 值，未找到设为 `15`；

13. 初始化类中变量 switch_line_time的值为参数服务器中的 `~switch_line_time` 值，未找到设为 `18`；

14.  初始化类 PDController的 对象 PD_controller 的值为 PDController(self.kp, self.kd, 1)；

15. 初始化类中变量 lining_flag 的值为 `LiningState.WAITING`； 

16. 初始化类中变量 switching_timer 的值为 0； 

17. 创建发布者：

	1. ctrl_publisher：发送 CtrlCommand 类型消息，话题名为 “ctrl_command”；

	2. mode_publisher：发送 ModeSwitch 类型消息，话题名为 “mode_switch”；

		​        将 mode_switch 的 target_mode 分量设为 `ModeSwitch.MOTION_MODE_STEERING`；

18. 创建订阅者：

	1. twist_subscriber：订阅话题名为“duihang”，消息类型为 Twist 的消息，回调函数为 LiningMsgHandler；

		回调函数：

		1. 接收 Twist 消息类型的变量为 twist_msg；

		2. 类中变量 timeout_cnt 设置为 类中变量 timeout 的值；

		3. 如果类中变量 lining_flag 等于 `LiningState.LINING`：

			1. 如果类中变量 twist_msg 的分量 linear.x 的值不等于 0：
				1. weighted_angle 的值为 `twist_msg.angular.y * self.d_weight + twist_msg.angular.z * self.theta_weight`；
				2. 类 PDController 对象 PD_controller 的 feedback 值为上述的 weighted_angle；
				3. 类中变量 lining_speed 的值为 0.5；
			2. 否则：
				1. 对象 PD_controller 中的部分值（error、feedback 和 reference）全部清0；
				2. 类中变量 lining_speed 的值设为 0.5；
				3. 设置类中变量 switching_timer 为当前的时间戳；
				4. 终端打印：`switch line`；

		4. 如果类中变量 lining_flag 等于 `LiningState.WAITING`：

			1. 如果类中变量 twist_msg 的分量 linear.x 的值不等于 0：

				1. 类中变量 lining_flag 设为 `LiningState.LINING`；
				2. weighted_angle 的值为 `twist_msg.angular.y * self.d_weight + twist_msg.angular.z * self.theta_weight`；
				3. 类 PDController 对象 PD_controller 的 feedback 值为上述的 weighted_angle；
				4. 类中变量 lining_speed 的值设为 0.5；
				5. 终端打印：`start lining`；

			2. 否则：

				1. 类中变量 lining_flag 设为 `LiningState.ERROR`；
				2. 对象 PD_controller 中的部分值（error、feedback 和 reference）全部清0；
				3. 终端打印：`error state`；

				

###### 方法2：LiningMsgHandler()

1. 类中变量 timeout_cnt 设置为 类中变量 timeout 的值；

2. 如果类中变量 lining_flag 等于 `LiningState.LINING`：

	1. 如果类中变量 twist_msg 的分量 linear.x 的值不等于 0：
		1. weighted_angle 的值为 `twist_msg.angular.y * self.d_weight + twist_msg.angular.z * self.theta_weight`；
		2. 类 PDController 对象 PD_controller 的 feedback 值为上述的 weighted_angle；
		3. 类中变量 lining_speed 的值为 0.5；
	2. 否则：
		1. 对象 PD_controller 中的部分值（error、feedback 和 reference）全部清0；
		2. 类中变量 lining_speed 的值设为 0.5；
		3. 设置类中变量 switching_timer 为当前的时间戳；
		4. 终端打印：`switch line`；

3. 如果类中变量 lining_flag 等于 `LiningState.WAITING`：

	1. 如果类中变量 twist_msg 的分量 linear.x 的值不等于 0：

		1. 类中变量 lining_flag 设为 `LiningState.LINING`；
		2. weighted_angle 的值为 `twist_msg.angular.y * self.d_weight + twist_msg.angular.z * self.theta_weight`；
		3. 类 PDController 对象 PD_controller 的 feedback 值为上述的 weighted_angle；
		4. 类中变量 lining_speed 的值设为 0.5；
		5. 终端打印：`start lining`；

	2. 否则：

		1. 类中变量 lining_flag 设为 `LiningState.ERROR`；
		2. 对象 PD_controller 中的部分值（error、feedback 和 reference）全部清0；
		3. 终端打印：`error state`；

		

###### 方法3：ControlOnce()

话题超时处理：

1. 如果类中变量 timeout_cnt 的值大于 0：

	1. 类中变量 timeout_cnt 的值减去 1000 / self.control_rate；

2. 否则：

	1. 类中变量 lining_flag 的值设为 `LiningState.WAITING`；
	2. 对象 PD_controller 中的部分值（error、feedback 和 reference）全部清0；

	

路线控制：

1. 如果类中变量 lining_flag 的值等于`LiningState.LINING`：

	1. 调用类 PDController 的对象 PD_controller 的 CalcError() 方法；
	2. 调用类 PDController 的对象 PD_controller 的 CalcOutPut() 方法；
	3. 调用 MoveCtrl() 方法，传入参数（类中变量 lining_speed，对象 PD_controller 的变量 output），即：速度(speed)和角度(angle)：
		1. 接收参数的变量为 speed 和 angle；
		2. 类中变量 ctrl_command 的分量 driving_speed 设为 speed；
		3. 类中变量 ctrl_command 的分量 steering_angle 设为 angle；
		4. 调用发布者 ctrl_publisher 发布类中变量 ctrl_command 的值；

2. 如果类中变量 lining_flag 的值等于 `LiningState.SWITCHING_LEFT`：

	1. 如果 （当前时间戳 `-` 类中变量 switching_timer 的值）小于 类中变量 out_line_time 的值：
		1. 调用 MoveCtrl() 方法，传入参数（1，0），即：速度(speed)和角度(angle)：
			1. 接收参数的变量为 speed 和 angle；
			2. 类中变量 ctrl_command 的分量 driving_speed 设为 speed；
			3. 类中变量 ctrl_command 的分量 steering_angle 设为 angle；
			4. 调用发布者 ctrl_publisher 发布类中变量 ctrl_command 的值；
		2. 终端打印：`now is 1#############################go out`；
	2. 如果 （当前时间戳 `-` 类中变量 switching_timer 的值）小于 （类中变量 out_line_time  `+` 类中变量 rotation_time 的值）：
		1. 调用 SwitchModeCtrl() 方法，传入参数：`ModeSwitch.MOTION_MODE_ROTATION`：
			1. 接收 ModeSwitch (自定义消息类型)消息类型的变量为 mode； 
			2. 如果传入函数的参数 mode 不等于 类中变量 mode_switch 的分量 target_mode 的值：
				1. 设置类中变量 mode_switch 的分量 target_mode 的值为传入参数 mode 的值；
				2. 调用发布者 mode_publisher 发布类中变量 mode_switch 的值；
		2. 调用 MoveCtrl() 方法，传入参数（-1，0），即：速度(speed)和角度(angle)：
			1. 接收参数的变量为 speed 和 angle；
			2. 类中变量 ctrl_command 的分量 driving_speed 设为 speed；
			3. 类中变量 ctrl_command 的分量 steering_angle 设为 angle；
			4. 调用发布者 ctrl_publisher 发布类中变量 ctrl_command 的值；
		3. 终端打印：`now is 2****************************rotation`；
	3. 如果 （当前时间戳 `-` 类中变量 switching_timer 的值）小于 （类中变量 out_line_time  + 类中变量 rotation_time `+` 6 的和）：
		1. 调用 SwitchModeCtrl() 方法，传入参数：`ModeSwitch.MOTION_MODE_TRANSLATION`：
			1. 接收 ModeSwitch (自定义消息类型)消息类型的变量为 mode； 
			2. 如果传入函数的参数 mode 不等于 类中变量 mode_switch 的分量 target_mode 的值：
				1. 设置类中变量 mode_switch 的分量 target_mode 的值为传入参数 mode 的值；
				2. 调用发布者 mode_publisher 发布类中变量 mode_switch 的值；
		2. 调用 MoveCtrl() 方法，传入参数（0，1），即：速度(speed)和角度(angle)：
			1. 接收参数的变量为 speed 和 angle；
			2. 类中变量 ctrl_command 的分量 driving_speed 设为 speed；
			3. 类中变量 ctrl_command 的分量 steering_angle 设为 angle；
			4. 调用发布者 ctrl_publisher 发布类中变量 ctrl_command 的值；
		3. 终端打印：`now is 3 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ right`；
	4. 如果 （当前时间戳 `-` 类中变量 switching_timer 的值）小于 （类中变量 out_line_time  + 类中变量 rotation_time `+` 类中变量 switch_line_time 的和）：
		1. 调用 MoveCtrl() 方法，传入参数（1，1），即：速度(speed)和角度(angle)：
			1. 接收参数的变量为 speed 和 angle；
			2. 类中变量 ctrl_command 的分量 driving_speed 设为 speed；
			3. 类中变量 ctrl_command 的分量 steering_angle 设为 angle；
			4. 调用发布者 ctrl_publisher 发布类中变量 ctrl_command 的值；
		2. 终端打印：`now is 4 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^`；
	5. 如果 （当前时间戳 `-` 类中变量 switching_timer 的值）小于 （类中变量 out_line_time  + 类中变量 rotation_time `+` 类中变量 switch_line_time  `+` 3 的和）：
		1. 调用 MoveCtrl() 方法，传入参数（0，0），即：速度(speed)和角度(angle)：
			1. 接收参数的变量为 speed 和 angle；
			2. 类中变量 ctrl_command 的分量 driving_speed 设为 speed；
			3. 类中变量 ctrl_command 的分量 steering_angle 设为 angle；
			4. 调用发布者 ctrl_publisher 发布类中变量 ctrl_command 的值；
		2. 终端打印：`now is 5 $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$`；
	6. 如果 （当前时间戳 `-` 类中变量 switching_timer 的值）小于 （类中变量 out_line_time  + 类中变量 rotation_time `+` 类中变量 switch_line_time  `+` 7 的和）：
		1. 调用 MoveCtrl() 方法，传入参数（1，0），即：速度(speed)和角度(angle)：
			1. 接收参数的变量为 speed 和 angle；
			2. 类中变量 ctrl_command 的分量 driving_speed 设为 speed；
			3. 类中变量 ctrl_command 的分量 steering_angle 设为 angle；
			4. 调用发布者 ctrl_publisher 发布类中变量 ctrl_command 的值；
		2. 终端打印：`now is !!!!!!!!!!!!!!!!!!!!!!!!!`；
	7. 不满足以上情况，则：
		1. 调用 SwitchModeCtrl() 方法，传入参数：`ModeSwitch.MOTION_MODE_STEERING`：
			1. 接收 ModeSwitch (自定义消息类型)消息类型的变量为 mode； 
			2. 如果传入函数的参数 mode 不等于 类中变量 mode_switch 的分量 target_mode 的值：
				1. 设置类中变量 mode_switch 的分量 target_mode 的值为传入参数 mode 的值；
				2. 调用发布者 mode_publisher 发布类中变量 mode_switch 的值；
		2. 设置类中变量 lining_flag 的值为 `LiningState.WAITING`；
		3. 终端打印：`now is 6~~~~~~~~~~~~~~~~~~~~~~~~~~~~~waiting`；

	

3. 如果类中变量 lining_flag 的值等于 `LiningState.SWITCHING_RIGHT`：pass

4. 不满足以上情况，则：

	1. 调用 MoveCtrl() 方法，传入参数（0，0），即：速度(speed)和角度(angle)：
		1. 接收参数的变量为 speed 和 angle；
		2. 类中变量 ctrl_command 的分量 driving_speed 设为 speed；
		3. 类中变量 ctrl_command 的分量 steering_angle 设为 angle；
		4. 调用发布者 ctrl_publisher 发布类中变量 ctrl_command 的值；

	

###### 方法4：MoveCtrl()（参数：speed，angle）

1. 接收参数的变量为 speed 和 angle；
2. 类中变量 ctrl_command 的分量 driving_speed 设为 speed；
3. 类中变量 ctrl_command 的分量 steering_angle 设为 angle；
4. 调用发布者 ctrl_publisher 发布类中变量 ctrl_command 的值；



###### 方法5：SwitchModeCtrl()（参数：mode）

1. 接收 ModeSwitch (自定义消息类型)消息类型的变量为 mode； 
2. 如果传入函数的参数 mode 不等于 类中变量 mode_switch 的分量 target_mode 的值：
	1. 设置类中变量 mode_switch 的分量 target_mode 的值为传入参数 mode 的值；
	2. 调用发布者 mode_publisher 发布类中变量 mode_switch 的值



###### 方法6：MainLoop()

1. 如果节点未关闭：

	1. 调用 ControlOnce() 方法
	2. ros 休眠



## 5、lining_ctrl.py (路线跟踪)

### 1、涉及的自定义消息类型

#### 1.1	CtrlComand.msg

行驶速度和转向角度：

```
float32 driving_speed
float32 steering_angle
```



#### 1.2	ModeSwitch.msg

目标模式：行驶、转换、旋转

```
uint8 target_mode
uint8 MOTION_MODE_STEERING = 0
uint8 MOTION_MODE_TRANSLATION = 1
uint8 MOTION_MODE_ROTATION = 2
```



### 2、程序解析

#### 类

##### 类1：PDController()

###### 方法1：初始化（init）（参数列表：`kp`，`kd`，`output_max`）

1. 类中变量 kp 的值设为传入参数 kp；
2. 类中变量 kd 的值设为传入参数 kd；
3. 类中变量 output_max 的值设为传入参数 output_max；
4. 类中列表变量 error 的值初始化为 `[0, 0, 0]`；
5. 类中变量 feedback 的值设为 0；
6. 类中变量 reference 的值设为 0；
7. 类中变量 output 的值设为 0；



###### 方法2：Clear()（清零方法）

1. 类中列表变量 error 的值设为 `[0, 0, 0]`；
2. 类中变量 feedback 的值设为传入参数 0；
3. 类中变量 reference 的值设为传入参数 0；



###### 方法3：CalcError()

1. 类中列表变量 error 的第2个参数为列表变量 error 的第1个参数值；
2. 类中列表变量 error 的第1个参数为类中变量 reference 减去类中变量 feedback 的值；



###### 方法4：CalcOutPut()

1. 类中列表变量 output 的值为 `self.error[0] * self.kp + (self.error[0] - self.error[1]) * self.kd`；

	这个公式是**离散时间PID控制器**的一部分。它用来计算PID控制器的输出。具体来说：

	1. self.error[0] 表示当前时刻的误差（偏差）值。
	2. self.error[1] 表示上一个时刻的误差（偏差）值。
	3. self.kp 是比例增益（Proportional gain）。
	4. self.kd 是微分增益（Derivative gain）。
	5. 公式的第一部分 self.error[0] * self.kp 计算了比例控制器的输出，即根据当前误差值计算出的控制量。

	公式的第二部分 (self.error[0] - self.error[1]) * self.kd 计算了微分控制器的输出，即当前误差值与上一个时刻的误差值之差乘以微分增益。

	这两部分的和即为PID控制器的输出，用来调节系统以减小误差。

2. 保持类中变量 output 的值始终在区间 `[-output_max, output_max]` 中，超出范围，则设为最接近的区间边界值。



##### 类2： LiningState(枚举类)

```
WAITING = 0         # 等待路线信息
LINING = 1          # 跟随线路
LEAVE = 2           # 离开线路
SWITCHING = 3       # 切换线路
ERROR = 4           # 线路错误
```



##### 类3：LiningController

###### 方法1：初始化（init）

1. 初始化 ros 匿名节点为 lining_ctrl； 

2. 初始化类中变量 d_weight 的值为参数服务器中的 `~d_weight`，未找到设为 1；

3.  初始化类中变量 theta_weight 的值为 `1 - self.d_weight`；

4. 初始化类中变量 kp 的值为参数服务器中的 `~kp` 值，未找到设为 `-0.5`；

5. 初始化类中变量 kd 的值为参数服务器中的 `~kd` 值，未找到设为 `-13.3`；

6. 初始化类中变量 place_length 的值为参数服务器中的 `~place_length` 值，未找到设为 `5`；

7. 初始化类中变量 place_width 的值为参数服务器中的 `~place_width` 值，未找到设为 `4`；

8. 初始化类中变量 lining_speed 的值为参数服务器中的 `~lining_speed` 值，未找到设为 `1`；

9. 初始化类中变量 control_rate 的值为参数服务器中的 `~control_rate` 值，未找到设为 `10`；

10. 初始化ROS 频率控制器 rate 的值为类中变量 `control_rate` 值；

11. 初始化类中变量 timeout 的值为参数服务器中的 `~timeout`值 * 1000，未找到设为 `1`；

12. 初始化类中变量 timeout_cnt 的值为类中变量 `timeout` 值； 

13. 初始化类中变量 autoflag 的值为 0；

14.  初始化类 PDController的 对象 PD_controller 的值为 PDController(self.kp, self.kd, 1)；

15. 初始化类中变量 lining_flag 的值为 `LiningState.WAITING`； 

16. 初始化类中变量 distance 的值为 0；

17.  初始化类中变量 dis_reset_flag 的值为 0；

18.  初始化类中变量 rx_command_num 的值为 0；

19.  初始化类中变量 mode_change_value 的值为 0；

20.  初始化类中变量 switch_time 的值为当前时间戳；

21.  初始化类中变量 leaveflag 的值为 0；

22.  初始化类中变量 last_distance 的值为 10000；

23. 创建发布者：

	1. ctrl_publisher：发送 CtrlCommand 类型消息，话题名为 “ctrl_command”；

	2. mode_publisher：发送 ModeSwitch 类型消息，话题名为 “mode_switch”；

		​        将 mode_switch 的 target_mode 分量设为 `ModeSwitch.MOTION_MODE_STEERING`；

	3. tx_command_publisher：发送 ModeSwitch 类型消息，话题名为 “tx_command”；

24. 创建订阅者：

	1. twist_subscriber：订阅话题名为“duihang”，消息类型为 Twist 的消息，回调函数为 LiningMsgHandler；

		回调函数：

		1. 接收 Twist 消息类型的变量为 twist_msg；
		2. 类中变量 timeout_cnt 设置为 类中变量 timeout 的值；
		3. 如果类中变量 lining_flag 等于 `LiningState.LINING`：
			1. 如果类中变量 twist_msg 的分量 linear.x 的值不等于 0：
				1. weighted_angle 的值为 `twist_msg.angular.y * self.d_weight + twist_msg.angular.z * self.theta_weight`；
				2. 类 PDController 对象 PD_controller 的 feedback 值为上述的 weighted_angle；
				3. 类中变量 leaveflag 的值为0；
				4. 类中变量 lining_speed 的值为 0.7；
			2. 否则：
				1. 对象 PD_controller 中的部分值（error、feedback 和 reference）全部清0；
				2. 如果 leaveflag 值为 0：
					1. 将 leaveflag 置1；
					2. 将 last_distance 置为类中变量 distance 的值；
					3. 终端打印：`leave======================================flag`；
					4. 终端打印：类中变量 last_distance 的值
				3. 类中变量 lining_speed 的值设为 0.7；
		4. 如果类中变量 lining_flag 等于 `LiningState.WAITING`：
			1. 如果类中变量 twist_msg 的分量 linear.x 的值不等于 0：
				1. 类中变量 lining_flag 设为 `LiningState.LINING`
				2. weighted_angle 的值为 `twist_msg.angular.y * self.d_weight + twist_msg.angular.z * self.theta_weight`；
				3. 类 PDController 对象 PD_controller 的 feedback 值为上述的 weighted_angle；
				4. 类中变量 leaveflag 的值为0；
				5. 类中变量 lining_speed 的值为 0.7；
				6. 终端打印：`ready lining`。
			2. 否则：
				1. 对象 PD_controller 中的部分值（error、feedback 和 reference）全部清0；
				2. 调用类的 TxCommand() 方法，传入参数5：
					1. 终端打印：`tx command num:`
					2. 终端打印：`num` 的值；
					3. 类中变量 tx_command 的值设为 num；
					4. 使用发布者 tx_command_publisher 发布类中变量 tx_command 的值。
				3. 终端打印：`error state`。

	2. sub_mode_fb：订阅话题名为“mode_fb_num”，消息类型为 Int8 的消息，回调函数为 ModeFbHandler；

		回调函数：

		1. 接收 Int8 消息类型的变量为 mode_fb；
		2. 类中变量 mode_change_value 的值设为 mode_fb 中的data 内容；
		3. 终端打印：`mode change ok`。

	3. sub_rx_command：订阅话题名为“rx_command”，消息类型为 Int8 的消息，回调函数为 RxCommandHandler；

		回调函数：

		1. 接收 Int8 消息类型的变量为 rx_num；
		2. 类中变量 rx_command_num 的值设为 rx_num 中的data 内容；
		3. 终端打印：`rx command num ok`；
		4. 终端打印：类中变量 rx_command_num 的值。

	4. sub_distance：订阅话题名为“distance”，消息类型为 Float32 的消息，回调函数为 GetDistanceHandler；

		回调函数：

		1. 接收 Float32 消息类型的变量为 dis；
		2. 类中变量 distance 的值设为 dis 中的data 内容；
		3. 终端打印：`get distance:`
		4. 终端打印：类中变量 distance 的值。

###### 方法2：LiningMsgHandler()

1. 接收 Twist 消息类型的变量为 twist_msg；
2. 类中变量 timeout_cnt 设置为 类中变量 timeout 的值；
3. 如果类中变量 lining_flag 等于 `LiningState.LINING`：
	1. 如果类中变量 twist_msg 的分量 linear.x 的值不等于 0：
		1. weighted_angle 的值为 `twist_msg.angular.y * self.d_weight + twist_msg.angular.z * self.theta_weight`；
		2. 类 PDController 对象 PD_controller 的 feedback 值为上述的 weighted_angle；
		3. 类中变量 leaveflag 的值为0；
		4. 类中变量 lining_speed 的值为 0.7；
	2. 否则：
		1. 对象 PD_controller 中的部分值（error、feedback 和 reference）全部清0；
		2. 如果 leaveflag 值为 0：
			1. 将 leaveflag 置1；
			2. 将 last_distance 置为类中变量 distance 的值；
			3. 终端打印：`leave======================================flag`；
			4. 终端打印：类中变量 last_distance 的值
		3. 类中变量 lining_speed 的值设为 0.7；
4. 如果类中变量 lining_flag 等于 `LiningState.WAITING`：
	1. 如果类中变量 twist_msg 的分量 linear.x 的值不等于 0：
		1. 类中变量 lining_flag 设为 `LiningState.LINING`
		2. weighted_angle 的值为 `twist_msg.angular.y * self.d_weight + twist_msg.angular.z * self.theta_weight`；
		3. 类 PDController 对象 PD_controller 的 feedback 值为上述的 weighted_angle；
		4. 类中变量 leaveflag 的值为0；
		5. 类中变量 lining_speed 的值为 0.7；
		6. 终端打印：`ready lining`。
	2. 否则：
		1. 对象 PD_controller 中的部分值（error、feedback 和 reference）全部清0；
		2. 调用类的 TxCommand() 方法，传入参数5：
			1. 终端打印：`tx command num:`
			2. 终端打印：`num` 的值；
			3. 类中变量 tx_command 的值设为 num；
			4. 使用发布者 tx_command_publisher 发布类中变量 tx_command 的值。
		3. 终端打印：`error state`



###### 方法3：ModeFbHandler()

1. 接收 Int8 消息类型的变量为 mode_fb；
2. 类中变量 mode_change_value 的值设为 mode_fb 中的data 内容；
3. 终端打印：`mode change ok`。



###### 方法4：RxCommandHandler()

1. 接收 Int8 消息类型的变量为 rx_num；
2. 类中变量 rx_command_num 的值设为 rx_num 中的data 内容；
3. 终端打印：`rx command num ok`；
4. 终端打印：类中变量 rx_command_num 的值。



###### 方法5：GetDistanceHandler()

1. 接收 Float32 消息类型的变量为 dis；
2. 类中变量 distance 的值设为 dis 中的data 内容；
3. 终端打印：`get distance:`
4. 终端打印：类中变量 distance 的值。



###### 方法6：ControlOnce()

话题超时处理：

1. 如果类中变量 timeout_cnt 的值大于 0：
	1. 类中变量 timeout_cnt 的值 减去 1000 / self.control_rate；
2. 否则：
	1. 类中变量 lining_flag 的值设为 `LiningState.WAITING`；
	2. 对象 PD_controller 中的部分值（error、feedback 和 reference）全部清0；
	3. 终端打印：`error state: lining topic timeout`

路线控制：

1. 如果类中变量 lining_flag 的值等于`LiningState.LINING`：

	1. 终端打印：`start lining`；
	2. 如果类中变量 rx_command_num 的值等于 2 ，并且类中变量 dis_reset_flag 的值等于 0，并且类中变量 mode_change_value 的值等于 1：
		1. 类中变量 dis_reset_flag 的值等于 1
	3. 如果类中变量 dis_reset_flag 的值等于 0 ，并且类中变量 mode_change_value 的值等于 1：
		1. 类中变量 distance 的值等于 0;
		2. 调用类的 TxCommand() 方法，传入参数4：
			1. 终端打印：`tx command num:`
			2. 终端打印：`num` 的值；
			3. 类中变量 tx_command 的值设为 num；
			4. 使用发布者 tx_command_publisher 发布类中变量 tx_command 的值。
	4. 如果类中变量 mode_change_value 的值等于 0 ：
		1. 调用方法 `SwitchModeCtrl()`，传入参数 `ModeSwitch.MOTION_MODE_STEERING`：
			1. 接收 ModeSwitch (自定义消息类型)消息类型的变量为 mode； 
			2. 终端打印：`set mode num:`；
			3. 终端打印：mode 的值；
			4. 设置类中变量 mode_switch 的分量 target_mode 的值为 mode；
			5. 调用发布者 mode_publisher 发布类中变量 mode_switch 的值。
	5. 如果类中变量 distance 的值大于等于 6000：
		1. 调用 MoveCtrl() 方法，传入参数（0，0），即：速度(speed)和角度(angle)：
			1. 接收参数的变量为 speed 和 angle；
			2. 类中变量 ctrl_command 的分量 driving_speed 设为 speed；
			3. 类中变量 ctrl_command 的分量 steering_angle 设为 angle；
			4. 调用发布者 tx_command_publisher 发布类中变量 tx_command 的值；
		2. 类中变量 lining_flag 的值设为 `LiningState.LEAVE`；
		3. 类中变量 rx_command_num 的值设为 0；
		4. 类中变量 dis_reset_flag 的值设为 0；
		5. 类中变量 mode_change_value 的值设为 0；
	6. 如果类中变量 distance 的值大于等于 3000：
		1. 终端打印：`delta dis:`；
		2. 终端打印：类中变量 distance 的值减去 类中变量 last_distance；
		3. 类中变量 lining_flag 的值设为 `LiningState.LEAVE`；
		4. 类中变量 rx_command_num 的值设为 0；
		5. 类中变量 dis_reset_flag 的值设为 0；
		6. 类中变量 mode_change_value 的值设为 0；
		7. 调用 MoveCtrl() 方法，传入参数（0，0），即：速度(speed)和角度(angle)：
			1. 接收参数的变量为 speed 和 angle；
			2. 类中变量 ctrl_command 的分量 driving_speed 设为 speed；
			3. 类中变量 ctrl_command 的分量 steering_angle 设为 angle；
			4. 调用发布者 tx_command_publisher 发布类中变量 tx_command 的值；
	7. 不满足以上情况，则：
		1. 终端打印：`delta dis:`；
		2. 终端打印：类中变量 distance 的值减去 类中变量 last_distance；
		3. 调用对象 PD_controller 的 CalcError() 方法：
			1. 类中列表变量 error 的第2个参数 为 列表变量 error 的第1个参数值；
			2. 类中列表变量 error 的第1个参数为类中变量 reference 减去类中变量 feedback 的值。
		4. 调用对象 PD_controller 的 CalcOutPut() 方法：
			1. 类中列表变量 output 的值为 `self.error[0] * self.kp + (self.error[0] - self.error[1]) * self.kd`；
			2. 保持类中变量 output 的值始终在区间 `[-output_max, output_max]` 中，超出范围，则设为最接近的区间边界值。
		5. 调用 MoveCtrl() 方法，传入参数（类中变量 lining_speed，类中变量 PD_controller 的 output），即：速度(speed)和角度(angle)：
			1. 接收参数的变量为 speed 和 angle；
			2. 类中变量 ctrl_command 的分量 driving_speed 设为 speed；
			3. 类中变量 ctrl_command 的分量 steering_angle 设为 angle；
			4. 调用发布者 tx_command_publisher 发布类中变量 tx_command 的值；
		6. 调用类的 TxCommand() 方法，传入参数 3：
			1. 终端打印：`tx command num:`
			2. 终端打印：`num` 的值；
			3. 类中变量 tx_command 的值设为 num；
			4. 使用发布者 tx_command_publisher 发布类中变量 tx_command 的值。

2. 如果类中变量 lining_flag 的值等于`LiningState.LEAVE`：

	1. 终端打印：`leave the line`；
	2. 如果类中变量 rx_command_num 的值等于 2 ，并且类中变量 dis_reset_flag 的值等于 0，并且类中变量 mode_change_value 的值等于 1：
		1. 设置 dis_reset_flag 为1
	3. 如果类中变量 dis_reset_flag 的值等于 0 ，并且类中变量 mode_change_value 的值等于 1：
		1. 类中变量 distance 的值等于 0;
		2. 调用类的 TxCommand() 方法，传入参数4：
			1. 终端打印：`tx command num:`
			2. 终端打印：`num` 的值；
			3. 类中变量 tx_command 的值设为 num；
			4. 使用发布者 tx_command_publisher 发布类中变量 tx_command 的值。
	4. 如果类中变量 mode_change_value 的值等于 0 ：
		1. 调用方法 `SwitchModeCtrl()`，传入参数 `ModeSwitch.MOTION_MODE_ROTATION`：
			1. 接收 ModeSwitch (自定义消息类型)消息类型的变量为 mode； 
			2. 终端打印：`set mode num:`；
			3. 终端打印：mode 的值；
			4. 设置类中变量 mode_switch 的分量 target_mode 的值为 mode；
			5. 调用发布者 mode_publisher 发布类中变量 mode_switch 的值。
	5. 如果类中变量 distance 的值大于等于 3100.0：
		1. 调用 MoveCtrl() 方法，传入参数（0，0），即：速度(speed)和角度(angle)：
			1. 接收参数的变量为 speed 和 angle；
			2. 类中变量 ctrl_command 的分量 driving_speed 设为 speed；
			3. 类中变量 ctrl_command 的分量 steering_angle 设为 angle；
			4. 调用发布者 tx_command_publisher 发布类中变量 tx_command 的值；
		2. 类中变量 lining_flag 的值设为 `LiningState.SWITCHING`；
		3. 类中变量 rx_command_num 的值设为 0；
		4. 类中变量 dis_reset_flag 的值设为 0；
		5. 类中变量 mode_change_value 的值设为 0；
	6. 不满足以上情况，则：
		1. 调用 MoveCtrl() 方法，传入参数（0.5，0），即：速度(speed)和角度(angle)：
			1. 接收参数的变量为 speed 和 angle；
			2. 类中变量 ctrl_command 的分量 driving_speed 设为 speed；
			3. 类中变量 ctrl_command 的分量 steering_angle 设为 angle；
			4. 调用发布者 tx_command_publisher 发布类中变量 tx_command 的值；
		2. 调用类的 TxCommand() 方法，传入参数 3：
			1. 终端打印：`tx command num:`
			2. 终端打印：`num` 的值；
			3. 类中变量 tx_command 的值设为 num；
			4. 使用发布者 tx_command_publisher 发布类中变量 tx_command 的值。

	

3. 如果类中变量 lining_flag 的值等于`LiningState.SWITCHING`：

	1. 终端打印：`switching the line`；
	2. 如果类中变量 rx_command_num 的值等于 2 ，并且类中变量 dis_reset_flag 的值等于 0，并且类中变量 mode_change_value 的值等于 1：
		1. 设置 dis_reset_flag 为1
	3. 如果类中变量 dis_reset_flag 的值等于 0 ，并且类中变量 mode_change_value 的值等于 1：
		1. 类中变量 distance 的值等于 0;
		2. 调用类的 TxCommand() 方法，传入参数4：
			1. 终端打印：`tx command num:`
			2. 终端打印：`num` 的值；
			3. 类中变量 tx_command 的值设为 num；
			4. 使用发布者 tx_command_publisher 发布类中变量 tx_command 的值。
	4. 如果类中变量 mode_change_value 的值等于 0 ：
		1. 调用方法 `SwitchModeCtrl()`，传入参数 `ModeSwitch.MOTION_MODE_TRANSLATION`：
			1. 接收 ModeSwitch (自定义消息类型)消息类型的变量为 mode； 
			2. 终端打印：`set mode num:`；
			3. 终端打印：mode 的值；
			4. 设置类中变量 mode_switch 的分量 target_mode 的值为 mode；
			5. 调用发布者 mode_publisher 发布类中变量 mode_switch 的值。
		2. 类中变量 switch_time 的值设为当前时间戳；
	5. 如果类中变量 mode_change_value 的值等于 1，并且类中变量 dis_reset_flag 的值等于 1，并且当前时间戳 `-` 类中变量switch_time 的结果小于等于2：
		1. 调用 MoveCtrl() 方法，传入参数`（0，1）`，即：速度(speed)和角度(angle)：
			1. 接收参数的变量为 speed 和 angle；
			2. 类中变量 ctrl_command 的分量 driving_speed 设为 speed；
			3. 类中变量 ctrl_command 的分量 steering_angle 设为 angle；
			4. 调用发布者 tx_command_publisher 发布类中变量 tx_command 的值；
	6. 如果类中变量 distance 的值大于等于 1350.0：
		1. 调用 MoveCtrl() 方法，传入参数（0，0），即：速度(speed)和角度(angle)：
			1. 接收参数的变量为 speed 和 angle；
			2. 类中变量 ctrl_command 的分量 driving_speed 设为 speed；
			3. 类中变量 ctrl_command 的分量 steering_angle 设为 angle；
			4. 调用发布者 tx_command_publisher 发布类中变量 tx_command 的值；
		2. 类中变量 lining_flag 的值设为 `LiningState.LINING`；
		3. 类中变量 rx_command_num 的值设为 0；
		4. 类中变量 dis_reset_flag 的值设为 0；
		5. 类中变量 mode_change_value 的值设为 0；
		6. 类中变量 switch_time 的值设为当前时间戳；
	7. 不满足以上情况，则：
		1. 调用 MoveCtrl() 方法，传入参数（0.5，1），即：速度(speed)和角度(angle)：
			1. 接收参数的变量为 speed 和 angle；
			2. 类中变量 ctrl_command 的分量 driving_speed 设为 speed；
			3. 类中变量 ctrl_command 的分量 steering_angle 设为 angle；
			4. 调用发布者 tx_command_publisher 发布类中变量 tx_command 的值；
		2. 调用类的 TxCommand() 方法，传入参数 3：
			1. 终端打印：`tx command num:`
			2. 终端打印：`num` 的值；
			3. 类中变量 tx_command 的值设为 num；
			4. 使用发布者 tx_command_publisher 发布类中变量 tx_command 的值。

4. 不满足上述情况：

	1. 调用 MoveCtrl() 方法，传入参数（0，0），即：速度(speed)和角度(angle)：
		1. 接收参数的变量为 speed 和 angle；
		2. 类中变量 ctrl_command 的分量 driving_speed 设为 speed；
		3. 类中变量 ctrl_command 的分量 steering_angle 设为 angle；
		4. 调用发布者 tx_command_publisher 发布类中变量 tx_command 的值；



###### 方法7：MoveCtrl()（参数：speed，angle）

1. 接收参数的变量为 speed 和 angle；
2. 类中变量 ctrl_command 的分量 driving_speed 设为 speed；
3. 类中变量 ctrl_command 的分量 steering_angle 设为 angle；
4. 调用发布者 tx_command_publisher 发布类中变量 tx_command 的值；



###### 方法8：TxCommand () （参数：num）

1. 终端打印：`tx command num:`
2. 终端打印：`num` 的值；
3. 类中变量 tx_command 的值设为 num；
4. 使用发布者 tx_command_publisher 发布类中变量 tx_command 的值。



###### 方法9：SwitchModeCtrl()（参数：mode）

1. 接收 ModeSwitch (自定义消息类型)消息类型的变量为 mode； 
2. 终端打印：`set mode num:`；
3. 终端打印：mode 的值；
4. 设置类中变量 mode_switch 的分量 target_mode 的值为 mode；
5. 调用发布者 mode_publisher 发布类中变量 mode_switch 的值。



###### 方法10：启动关闭视觉导航程序：Startvisual()

1. 将临时生成的 UUID 赋值给变量 uuid；
2. 将生成的 UUID 传递给 ROS Launch 日志记录系统；
3. 使用 launchgo 这个变量来标识 `/home/nvidia/catkin_ws/src/mower_ctrl/lining_visual.launch` 文件；
4. 使用 launchgo 的 start() 方法来启动该文件；
5. 终端打印日志：`go visual started`



###### 方法11：MainLoop()

1. 如果节点未关闭：

	1. 如果类中变量 rx_command_num 的值为 1：
		1. rx_command_num 的值设为0；
		2. 检测摄像头是否正常连接：
			1. cap 获取路径：`/dev/video-mid` 中的视频；
				1. 如果打开失败
					1. 终端打印：camera is error
					2. 调用方法TxCommand()，传入参数 1： 
						1. 终端打印：`tx command num:`
						2. 终端打印：`num` 的值；
						3. 类中变量 tx_command 的值设为 num；
						4. 使用发布者 tx_command_publisher 发布类中变量 tx_command 的值。
				2. 不满足上述情况：
					1. 终端打印：camera is conntect
					2. 释放 cap 资源；
					3. 调用方法TxCommand()，传入参数 2： 
						1. 终端打印：`tx command num:`
						2. 终端打印：`num` 的值；
						3. 类中变量 tx_command 的值设为 num；
						4. 使用发布者 tx_command_publisher 发布类中变量 tx_command 的值。
					4. 设置类中变量 autoflag 的值为 1；
					5. 调用 Startvisual() 方法：
						1. 将临时生成的 UUID 赋值给变量 uuid；
						2. 将生成的 UUID 传递给 ROS Launch 日志记录系统；
						3. 使用 launchgo 这个变量来标识 `/home/nvidia/catkin_ws/src/mower_ctrl/lining_visual.launch` 文件；
						4. 使用 launchgo 的 start() 方法来启动该文件；
						5. 终端打印日志：`go visual started`
	2. 如果类中变量 rx_command_num 的值为 3 并且类中变量 autoflag 的值为 1：
		1. 类中变量 rx_command_num 的值设为 0；
		2. 关闭 launchgo 对应的节点；
		3. 类中变量 timeout_cnt 的值设为类中变量 timeout；
		4. 类中变量 autoflag  的值设为 0；
		5. 类中变量 lining_flag 的值设为 `LiningState.WAITING`；
		6. 类中变量 distance 的值设为 0；
		7. 类中变量 mode_change_value 的值设为 0；
		8. 类中变量 switch_time 的值设为 当前时间戳；
		9. 对象PD_controller 调用方法 Clear()：
			1. 类中列表变量 error 的值设为 `[0, 0, 0]`；
			2. 类中变量 feedback 的值设为传入参数 0；
			3. 类中变量 reference 的值设为传入参数 0；
		10. 终端打印：`launch stop OK`
	3. 如果类中变量 autoflag 的值为 1 ：
		1. 调用 ControlOnce() 方法
	4. ros 休眠



## 6、motion_ctrl_fb.py			

### 1、涉及的自定义消息类型

#### 1.1	CtrlComand.msg

行驶速度和转向角度：

```
float32 driving_speed
float32 steering_angle
```



#### 1.2	ModeSwitch.msg

目标模式：行驶、转换、旋转

```
uint8 target_mode
uint8 MOTION_MODE_STEERING = 0
uint8 MOTION_MODE_TRANSLATION = 1
uint8 MOTION_MODE_ROTATION = 2
```



### 2、程序解析

#### 2.1	类

##### 类1：MotionController

###### 方法1：初始化方法（init）

1. 初始化节点名为：`motion_ctrl`；

2. 获取参数服务器中 `~serial_port` 的值，如果没有，则将类中变量 serial_port 的值设为 `/dev/ttyUSB2`；

3. 获取参数服务器中 `~serial_baudrate` 的值，如果没有，则将类中变量 serial_baudrate 的值设为 115200；

4. 获取参数服务器中 `~control_rate` 的值，如果没有，则将类中变量 control_rate 的值设为 10；

5. 定义一个 ROS 频率器控制对象 rate ，并设置其值为 `control_rate`，即：10

6. 设置类中变量 ctrl_count_down 的值为 0；

7. 设置类中变量 ctrl_command_str 的值为空字符串；

8. 设置类中变量列表 target_mode 的值为 `["ST", "TL", "RT"]`（TS：横向模式、VT：竖向模式和 ==RT==阿克曼）;

9. 初始化串口（名称、波特率、超时时间），如果失败，在日志中将错误记录为 `ERROR: fail to open control serial port`；

10. 创建发布者：

	1. mode_fb_int8_publisher：发送 Int8 类型消息，话题名为 “mode_fb_num”；

11. 创建订阅者：

	1. ctrl_subscriber：订阅话题名为“ctrl_command”，消息类型为 CtrlCommand （自定义消息类型）的消息，回调函数为 CtrlCommandHandler；

		回调函数：

		1. 接收 CtrlCommand  消息类型的变量为 ctrl_msg；
		2. 将接收到的 ctrl_msg 中的 driving_speed ，赋值给类中变量driving_speed；
		3. 将接收到的 ctrl_msg 中的 steering_angle ，赋值给类中变量steering_angle；
		4. 设置类中变量 ctrl_count_down 的值为 5；
		5. 对 driving_speed 和 steering_angle 进行格式处理（保留两位小数），形成字符串`"move ${speed} ${angle}"` 的格式并赋值给类中变量 ctrl_command_str；

		

	2. mode_subscriber：订阅话题名为“mode_switch”，消息类型为 ModeSwitch（自定义消息类型）的消息，回调函数为 ModeSwitchHandler；

		回调函数：

		1. 接收 ModeSwitch 消息类型的变量为 mode_index；
		2. mode_switch_command 的内容设置为 `"set_mode " + self.target_mode[mode_index.target_mode]`（也就是 `"set_mode "` 加上`"ST", "TL", "RT"` 其中之一）；
		3. 终端打印 mode_switch_command 的内容；
		4. 串口写入：mode_switch_command 的内容；

	

###### 方法2：析构函数（del）

程序结束关闭串口



###### 方法3：SerialCtrlOnce()

1. 如果类中变量 ctrl_count_down 的值大于 0：
	1. 类中变量 ctrl_count_down 的值自减1；
2. 否则：
	1. 类中变量 driving_speed 的值为 0；
	2. 类中变量 steering_angle 的值为 0；
	3. 对 driving_speed 和 steering_angle 进行格式处理（保留两位小数），形成字符串`"move ${speed} ${angle}"` 的格式并赋值给类中变量 ctrl_command_str；
3. 串口写入：ctrl_command_str 的内容



###### 方法4：CtrlCommandHandler()（接收参数：ctrl_msg，参数类型：CtrlCommand ）

1. 将接收到的 ctrl_msg 中的 driving_speed ，赋值给类中变量driving_speed；
2. 将接收到的 ctrl_msg 中的 steering_angle ，赋值给类中变量steering_angle；
3. 设置类中变量 ctrl_count_down 的值为 5；
4. 对 driving_speed 和 steering_angle 进行格式处理（保留两位小数），形成字符串`"move ${speed} ${angle}"` 的格式并赋值给类中变量 ctrl_command_str；



###### 方法5：ModeSwitchHandler()（参数：mode_index，参数类型：ModeSwitch ）

1. mode_switch_command 的内容设置为 `"set_mode " + self.target_mode[mode_index.target_mode]`（也就是 `"set_mode "` 加上`"ST", "TL", "RT"` 其中之一）；
2. 终端打印 mode_switch_command 的内容；
3. 串口写入：mode_switch_command 的内容；



###### 方法6：MainLoop()

节点未关闭：

1. 从串口逐行读取内容，存放入 feedback；
2. 如果读取的 feedback 内容长度大于1：
	1. 终端打印：`"RX: "` + feedback 内容；
	2. 如果 feedback 内容是：`#set_mode,OK,RT*\n` 或者 `#set_mode,OK,ST*\n` 或者 `#set_mode,OK,TL*\n`：
		1. 终端打印：`OKOKOKOKOK` ；
		2. 类中变量 mode_fb_int8 设为 1；
		3. 使用发布者 mode_fb_int8_publisher 发布 类中变量 mode_fb_int8；
3. 执行方法：SerialCtrlOnce()：
	1. 如果类中变量 ctrl_count_down 的值大于 0：
		1. 类中变量 ctrl_count_down 的值自减1；
	2. 否则：
		1. 类中变量 driving_speed 的值为 0；
		2. 类中变量 steering_angle 的值为 0；
		3. 对 driving_speed 和 steering_angle 进行格式处理（保留两位小数），形成字符串`"move ${speed} ${angle}"` 的格式并赋值给类中变量 ctrl_command_str；
	3. 串口写入：ctrl_command_str 的内容；
4. 按照 rate 设置的频率循环休眠。



## 7、motion_ctrl.py			

### 1、涉及的自定义消息类型

#### 1.1	CtrlComand.msg

行驶速度和转向角度：

```
float32 driving_speed
float32 steering_angle
```



#### 1.2	ModeSwitch.msg

目标模式：行驶、转换、旋转

```
uint8 target_mode
uint8 MOTION_MODE_STEERING = 0
uint8 MOTION_MODE_TRANSLATION = 1
uint8 MOTION_MODE_ROTATION = 2
```



### 2、程序解析

#### 2.1	类

##### 类1：MotionController

###### 方法1：初始化方法（init）

1. 初始化节点名为：`motion_ctrl`；

2. 获取参数服务器中 `~serial_port` 的值，如果没有，则将类中变量 serial_port 的值设为 `/dev/ttyTHS1`；

3. 获取参数服务器中 `~serial_baudrate` 的值，如果没有，则将类中变量 serial_baudrate 的值设为 115200；

4. 获取参数服务器中 `~control_rate` 的值，如果没有，则将类中变量 control_rate 的值设为 10；

5. 定义一个 ROS 频率器控制对象 rate ，并设置其值为 `control_rate`，即：10

6. 设置类中变量 ctrl_count_down 的值为 0；

7. 设置类中变量 ctrl_command_str 的值为空字符串；

8. 设置类中变量列表 target_mode 的值为 `["ST", "TL", "RT"]`（TS：横向模式、VT：竖向模式和 ==RT==阿克曼）;

9. 设置类中变量 mode_num 的值为0；

10. 设置类中变量 mode_count 的值为0；

11. 设置类中变量 autoflag 的值为0；

12. 设置类中变量列表 tx_command的值为 

	["#camera,ERROR\*\n", "#jeston_check,OK*\n", "get_distance\n", "distance_reset\n", "alignment_error\n"]

13. 设置类中变量 tx_count 的值为0；

14. 设置类中变量 tx_num 的值为0；

15. 设置类中变量 infocnt 的值为0；

16. 初始化串口（名称、波特率、超时时间），如果失败，在日志中将错误记录为 `ERROR: fail to open control serial port`；

17. 创建发布者：

	1. mode_fb_int8_publisher：发送 Int8 类型消息，话题名为 “mode_fb_num”；
	2. rx_command_publisher：发送 Int8 类型消息，话题名为 “rx_command”；
	3. distance_publisher：发送 Float32 类型消息，话题名为 “distance”；
	4. carinfo_publisher：发送 String 类型消息，话题名为 “car_info”；

18. 创建订阅者：

	1. ctrl_subscriber：

		1. 订阅话题名为“ctrl_command”，消息类型为 CtrlCommand （自定义消息类型）的消息，回调函数为 CtrlCommandHandler；

			回调函数：

			1. 接收 CtrlCommand  消息类型的变量为 ctrl_msg；
			2. 如果类中变量 ctrl_count_down 等于 0：
				1. 对接收到的 ctrl_msg 中的 driving_speed 保留两位小数，赋值给类中变量driving_speed；
				2. 对接收到的 ctrl_msg 中的 steering_angle 保留两位小数，赋值给类中变量steering_angle；
				3. 对 driving_speed 和 steering_angle 进行格式处理，形成字符串`"move ${speed} ${angle}"` 的格式并赋值给类中变量 ctrl_command_str；
				4. 如果类中变量 autoflag 的值等于 1：
					1. 类中变量 ctrl_count_down 清 0；
					2. 终端打印日志："TX: " + 类中变量：ctrl_command_str；
					3. 串口写入类中变量 ctrl_command_str 的值

		2. 订阅话题名为“tx_command”，消息类型为 Int8 的消息，回调函数为 TxCommandHandler；

			回调函数：

			1. 如果类中变量 tx_num 的值不等于 tx_num：
				1. 将 tx_num 赋给类中的变量 tx_num ；
				2. 类中变量 tx_count 清零；
			2. 如果类中变量 tx_count 等于 0 且 tx_num的值大于 0：
				1. 终端打印：tx_command 列表中的元素，元素下标为 tx_num.data-1；
				2. 串口写入 tx_command 列表中的元素，元素下标为 tx_num.data-1；
			3. 类中变量 tx_count 自加1；
			4. 如果类中变量 tx_count 等于 3 ：将该变量清0；

			

	2. mode_subscriber：订阅话题名为“mode_switch”，消息类型为 ModeSwitch（自定义消息类型）的消息，回调函数为 ModeSwitchHandler；

		回调函数：

		1. 接收 ModeSwitch 消息类型的变量为 mode_index；
		2. 如果类中变量 mode_num 不等于 mode_index：
			1. 类中变量 mode_num 设为 mode_index 的 target_mode
			2. 类中变量 mode_count 清零
		3. 如果类中变量 mode_count 等于 0：
			1. 类中变量 mode_num 设为 mode_index 消息的 target_mode；
			2. mode_switch_command 的内容设置为 `"set_mode " + self.target_mode[self.mode_num]`（也就是 `"set_mode "` 加上`"ST", "TL", "RT"` 其中之一）；
			3. 终端打印 mode_switch_command 的内容；
			4. 串口写入：mode_switch_command 的内容；
		4. 类中变量 mode_count 的值自加1；
		5. 如果类中变量 mode_count 的值为 3：对其进行清零操作。

19. 类中变量初始化：

	last_speed、last_angle、driving_speed、steering_angle全部清零

	

	

###### 方法2：析构函数（del）

程序结束关闭串口



###### 方法3：SerialCtrlOnce()

终端打印日志：`"TX: " + self.ctrl_command_str`



###### 方法4：CtrlCommandHandler()

1. 接收 CtrlCommand  消息类型的变量为 ctrl_msg；

2. 如果类中变量 ctrl_count_down 等于 0：

	1. 对接收到的 ctrl_msg 中的 driving_speed 保留两位小数，赋值给类中变量driving_speed；

	2. 对接收到的 ctrl_msg 中的 steering_angle 保留两位小数，赋值给类中变量steering_angle；

	3. 对 driving_speed 和 steering_angle 进行格式处理，形成字符串`"move ${speed} ${angle}"` 的格式并赋值给类中变量 ctrl_command_str；

	4. 如果类中变量 autoflag 的值等于 1：

		1. 类中变量 ctrl_count_down 清 0；
		2. 终端打印日志："TX: " + 类中变量：ctrl_command_str；
		3. 串口写入类中变量 ctrl_command_str 的值

		

###### 方法5：TxCommandHandler()

1. 如果类中变量 tx_num 的值不等于 tx_num：
	1. 将 tx_num 赋给类中的变量 tx_num ；
	2. 类中变量 tx_count 清零；
2. 如果类中变量 tx_count 等于 0 且 tx_num的值大于 0：
	1. 终端打印：tx_command 列表中的元素，元素下标为 tx_num.data-1；
	2. 串口写入 tx_command 列表中的元素，元素下标为 tx_num.data-1；
3. 类中变量 tx_count 自加1；
4. 如果类中变量 tx_count 等于 3 ：将该变量清0；



###### 方法6：ModeSwitchHandler()

1. 接收 CtrlCommand  消息类型的变量为 mode_index消息的 target_mode；
2. 如果类中变量 mode_num 不等于 mode_index：
	1. 类中变量 mode_num 设为 mode_index 的 target_mode
	2. 类中变量 mode_count 清零
3. 如果类中变量 mode_count 等于 0：
	1. 类中变量 mode_num 设为 mode_index 消息的 target_mode；
	2. mode_switch_command 的内容设置为 `"set_mode " + self.target_mode[self.mode_num]`（也就是 `"set_mode "` 加上`"ST", "TL", "RT"` 其中之一）；
	3. 终端打印 mode_switch_command 的内容；
	4. 串口写入：mode_switch_command 的内容；
4. 类中变量 mode_count 的值自加1；
5. 如果类中变量 mode_count 的值为 3：对其进行清零操作。



###### 方法7：MainLoop()

节点未关闭：

1. 如果类中变量 autoflag 等于 0：
	1. start_command 赋初值 `program_started\n`；
	2. 终端打印 start_command 的内容；
	3. 串口写入 start_command 的内容。
2. 从串口逐行读取内容，存放入 feedback；
3. 如果读取的 feedback 内容长度大于1：
	1. 终端打印：`"RX: "` + feedback 内容；
	2. 如果 feedback 内容是：`#program_started,OK*\n`：类中变量 autoflag 设为 1；
	3. 如果 feedback 内容是：`auto_work\n`：
		1. 终端打印：`auto work OK` ；
		2. 类中变量 rx_command设为 1；
		3. 使用发布者 rx_command_publisher 发布 类中变量 rx_command；
	4. 如果 feedback 内容是：`stop_work\n`：
		1. 终端打印：`stop work OK` ；
		2. 类中变量 rx_command设为 3；
		3. 使用发布者 rx_command_publisher 发布 类中变量 rx_command；
	5. 如果 feedback 内容是：`#set_mode,OK*\n`：
		1. 终端打印：`mode OK` ；
		2. 类中变量 mode_fb_int8 设为 1；
		3. 使用发布者 mode_fb_int8_publisher 发布 类中变量 mode_fb_int8；
	6. 如果 feedback 内容是：`#distance_reset,OK*\n`：
		1. 终端打印：`reset OK` ；
		2. 类中变量 rx_command 设为 2；
		3. 使用发布者 rx_command_publisher 发布 类中变量 rx_command；
	7. 除去以上情况：
		1. 对 feedback 先按 `*` 分段，并取第一段，按照 `,` 再次进行分段，最后将分段的结果赋值给列表 RX_DIS；
		2. 如果 RX_DIS 的第一段是 `#get_distance`，并且 RX_DIS 的第二段是 `OK`：
			1. 将 RX_DIS 的第三段转化为浮点型，并赋值给类中变量 distance；
			2. 终端打印：类中变量 distance 的值；
			3. 使用发布者 distance_publisher 发布类中变量 distance； 
		3. 如果 RX_DIS 的第一段是 `#move`，并且 RX_DIS 的第二段是 `OK`：
			1. 将 RX_DIS 的第 3 段转化为浮点型，并保留两位小数，处理后的数据赋值给类中变量 last_speed；
			2. 将 RX_DIS 的第 4 段转化为浮点型，并保留两位小数，处理后的数据赋值给类中变量 last_angle；
			3. 终端打印：`speed:` 加上类中变量 last_speed 的值；
			4. 终端打印：`angle:` 加上类中变量 last_angle 的值；
			5. 如果类中变量 last_speed 等于类中变量 driving_speed 并且类中变量 last_angle 等于类中变量 steering_angle：类中变量 ctrl_count_down 清 0；
		4. 如果 RX_DIS 的第一段是 `#read_carinfo`，并且 RX_DIS 的第二段是 `OK`：
			1. 类中变量 carinfo 设为 feedback；
			2. ==如果发布者 carinfo_publisher 发布类中变量 carinfo；==（是否行对错？该文件第164行）
4. 如果类中变量 autoflag 的值为 1
	1. 如果类中变量 infocnt 的值为 0：
		1. carinfo_command 赋值为 `read_carinfo\n`；
		2. 终端打印 carinfo_command 的值；
		3. 向串口写入  carinfo_command 的值；
		4. 类中变量 infocnt 自加 1
	2. 如果类中变量 infocnt 的值不为 0：
		1. 类中变量 infocnt 自加 1
		2. 如果类中变量 infocnt 的值等于 15：
			1. 类中变量 infocnt 的值清零
5. 按照 rate 设置的频率循环休眠



## 8、sample.py			

1. 导入必要的模块：
	1. RPi.GPIO as GPIO: 导入用于控制树莓派GPIO引脚的模块，并将其命名为GPIO。
	2. time: 导入时间模块，用于程序中的时间操作和延时。
	3. os: 导入操作系统模块，用于执行操作系统相关的命令。
	4. roslaunch: 导入用于启动ROS（机器人操作系统）launch文件的模块。
2. 定义了一个函数main()，其中的主要步骤包括：
	1. 打印一条信息 "py start"。
	2. 使用 time.sleep(50) 让程序休眠50秒。
	3. 生成一个UUID，配置日志，然后启动一个ROS的 launch 文件 (lining_ctrl.launch)。这里使用了roslaunch模块来启动ROS launch（`/home/robot/catkin_ws/src/mower_ctrl/lining_ctrl.launch`）文件。
	4. 通过 while 1: t=1 这个循环来持续保持程序运行状态，不执行其他操作。



## 9、send_info.py

### 1、涉及的自定义消息类型

#### 1.1	CtrlComand.msg

行驶速度和转向角度：

```
float32 driving_speed
float32 steering_angle
```



#### 1.2	ModeSwitch.msg

目标模式：行驶、转换、旋转

```
uint8 target_mode
uint8 MOTION_MODE_STEERING = 0
uint8 MOTION_MODE_TRANSLATION = 1
uint8 MOTION_MODE_ROTATION = 2
```



### 2、程序解析

#### 2.1	类

##### 类1：sendinfo

###### 方法1：初始化方法（init）

1. 初始化节点名为：`send_info`；

2. 获取参数服务器中 `~end_x` 的值，如果没有，则将类中变量 serial_port 的值设为 10；

3. 获取参数服务器中 `~end_y` 的值，如果没有，则将类中变量 end_y 的值设为 30；

4. 获取参数服务器中 `~control_rate` 的值，如果没有，则将类中变量 control_rate 的值设为 10；

5. 定义一个 ROS 频率器控制对象 rate ，并设置其值为 `control_rate`，即：10;

6. 创建发布者：

	1. sendXY_publisher：发送 Pose2D 类型消息，话题名为 “send_end_xy”；

	2. ctrl_publisher：发送 CtrlCommand 类型消息，话题名为 “ctrl_command”；

	3. mode_publisher：发送 ModeSwitch 类型消息，话题名为 “mode_switch”；

		​        将 mode_switch 的 target_mode 分量设为 `ModeSwitch.MOTION_MODE_STEERING`；

7. 声明变量 sendXY_msg 的消息类型为 Pose2D()；

8. 声明变量 ctrl_command 的消息类型为 CtrlCommand()；

9. 声明变量 mode_switch 的消息类型为 ModeSwitch()；

10. 获取参数服务器中 `~mode` 的值，如果没有，则将类中变量 mode 的值设为 2；

11. 获取参数服务器中 `~modecnt` 的值，如果没有，则将类中变量 modecnt 的值设为 1；

12. 初始化类中变量 last_time 的值为当前的时间戳；

13. 初始化类中变量 send_time 的值为 0；



###### 方法2：mode_set()（参数：mode，参数类型：ModeSwitch() (自定义消息类型)）

1. 如果参数 mode 等于1：
	1. 类中变量 send_time 的值等于 send_time +（当前时间戳与类中变量 last_time 的差值）；
	2. 类中变量 last_time 的值等于当前时间戳的值；
	3. 如果类中变量 send_time 的值小于5：
		1. 终端打印：`"time=%.2f",self.send_time`;
		2. 调用方法 SwitchModeCtrl()，并传入参数 `ModeSwitch.MOTION_MODE_ROTATION`：
			1. 方法参数为 mode ，参数类型为：ModeSwitch()（自定义 ROS 消息类型）
			2. 当类中变量 mode_switch 的 target_mode 分量不等于 `ModeSwitch.MOTION_MODE_ROTATION`：
				1. 设置类中变量 mode_switch 的 target_mode 分量等于`ModeSwitch.MOTION_MODE_ROTATION`；
			3. 使用发布者 mode_publisher 发布类中变量 mode_switch 的内容；
			4. 终端打印：`"mode=%d",self.mode_switch.target_mode`，即 mode 的当前内容；
		3. 调用方法 MoveCtrl()，并传入参数(0，0)：
			1. 函数参数为：speed、angle；
			2. 设置类中变量 ctrl_command 的分量 driving_speed 值为 speed；
			3. 设置类中变量 ctrl_command 的分量 steering_angle 值为 angle；
			4. 使用发布者 ctrl_publisher 发布类中变量 ctrl_command 的内容。
2. 如果参数 mode 等于 2：
	1. 调用方法 MoveCtrl()，并传入参数(self.modecnt, self.modecnt)：
		1. 函数参数为：speed、angle；
		2. 设置类中变量 ctrl_command 的分量 driving_speed 值为 speed；
		3. 设置类中变量 ctrl_command 的分量 steering_angle 值为 angle；
		4. 使用发布者 ctrl_publisher 发布类中变量 ctrl_command 的内容。
	2. 终端打印：`"MOVE=%.2f",self.modecnt`
3. 如果参数 mode 等于3：
	1. 调用方法 SwitchModeCtrl()，并传入参数 `ModeSwitch.MOTION_MODE_TRANSLATION`：
		1. 方法参数为 mode ，参数类型为：ModeSwitch()（自定义 ROS 消息类型）
		2. 当类中变量 mode_switch 的 target_mode 分量不等于 `ModeSwitch.MOTION_MODE_TRANSLATION`：
			1. 设置类中变量 mode_switch 的 target_mode 分量等于`ModeSwitch.MOTION_MODE_TRANSLATION`；
		3. 使用发布者 mode_publisher 发布类中变量 mode_switch 的内容；
		4. 终端打印：`"mode=%d",self.mode_switch.target_mode`，即 mode 的当前内容；
	2. 调用方法 MoveCtrl()，并传入参数(0，`-1`)：
		1. 函数参数为：speed、angle；
		2. 设置类中变量 ctrl_command 的分量 driving_speed 值为 speed；
		3. 设置类中变量 ctrl_command 的分量 steering_angle 值为 angle；
		4. 使用发布者 ctrl_publisher 发布类中变量 ctrl_command 的内容。
4. 如果参数 mode 等于 4：
	1. 调用方法 SwitchModeCtrl()，并传入参数 `ModeSwitch.MOTION_MODE_STEERING`：
		1. 方法参数为 mode ，参数类型为：ModeSwitch()（自定义 ROS 消息类型）
		2. 当类中变量 mode_switch 的 target_mode 分量不等于 `ModeSwitch.MOTION_MODE_STEERING`：
			1. 设置类中变量 mode_switch 的 target_mode 分量等于`ModeSwitch.MOTION_MODE_STEERING`；
		3. 使用发布者 mode_publisher 发布类中变量 mode_switch 的内容；
		4. 终端打印：`"mode=%d",self.mode_switch.target_mode`，即 mode 的当前内容；
	2. 调用方法 MoveCtrl()，并传入参数(0，0.5)：
		1. 函数参数为：speed、angle；
		2. 设置类中变量 ctrl_command 的分量 driving_speed 值为 speed；
		3. 设置类中变量 ctrl_command 的分量 steering_angle 值为 angle；
		4. 使用发布者 ctrl_publisher 发布类中变量 ctrl_command 的内容。
5. 不满足以上情况：
	1. 调用方法 SwitchModeCtrl()，并传入参数 `ModeSwitch.MOTION_MODE_STEERING`：
		1. 方法参数为 mode ，参数类型为：ModeSwitch()（自定义 ROS 消息类型）
		2. 当类中变量 mode_switch 的 target_mode 分量不等于 `ModeSwitch.MOTION_MODE_STEERING`：
			1. 设置类中变量 mode_switch 的 target_mode 分量等于`ModeSwitch.MOTION_MODE_STEERING`；
		3. 使用发布者 mode_publisher 发布类中变量 mode_switch 的内容；
		4. 终端打印：`"mode=%d",self.mode_switch.target_mode`，即 mode 的当前内容；
	2. 调用方法 MoveCtrl()，并传入参数(0，0)：
		1. 函数参数为：speed、angle；
		2. 设置类中变量 ctrl_command 的分量 driving_speed 值为 speed；
		3. 设置类中变量 ctrl_command 的分量 steering_angle 值为 angle；
		4. 使用发布者 ctrl_publisher 发布类中变量 ctrl_command 的内容。



###### 方法2：MoveCtrl() （参数：speed、angle）

1. 函数参数为：speed、angle；
2. 设置类中变量 ctrl_command 的分量 driving_speed 值为 speed；
3. 设置类中变量 ctrl_command 的分量 steering_angle 值为 angle；
4. 使用发布者 ctrl_publisher 发布类中变量 ctrl_command 的内容。



###### 方法3：SwitchModeCtrl() （参数：mode）

1. 方法参数为 mode ，参数类型为：ModeSwitch()（自定义 ROS 消息类型）
2. 当类中变量 mode_switch 的 target_mode 分量不等于 mode：
	1. 设置类中变量 mode_switch 的 target_mode 分量等于 mode；
3. 使用发布者 mode_publisher 发布类中变量 mode_switch 的内容；
4. 终端打印：`"mode=%d",self.mode_switch.target_mode`，即 mode 的当前内容；



###### 方法4：MainLoop()

节点未关闭：

1. 调用 mode_set() 方法传入参数为：类中变量 mode 的值：
2. 循环休眠





# 2、flower 功能包

## 1、hfflowerbl.cpp

## 2、hfflowerbr.cpp

## 3、hfflowerfl.cpp

1. 初始化节点名为 `velocity_publisher`；

2. 创建节点句柄 `n`；

3. 从ROS参数服务器中获取名为 `/hffl/camera_x` 的 int 型参数值，如果参数不存在，则使用默认值 190；

4. 从ROS参数服务器中获取名为 `/hffl/camera_y` 的 int 型参数值，如果参数不存在，则使用默认值 290；

5. 从ROS参数服务器中获取名为 `/hffl/camera_x` 的 int 型参数值，如果参数不存在，则使用默认值190；

6. 从ROS参数服务器中获取名为 `/hffl/camera_h` 的 int 型参数值，如果参数不存在，则使用默认值 240；

7. 从ROS参数服务器中获取名为 `/hffl/camera_w` 的 int 型参数值，如果参数不存在，则使用默认值 150；

8. 创建一个名为 `Duihang` 的 ROS 话题发布者，用于发布  `geometry_msgs::Twist` 类型的消息到名为 "duihang" 的话题上，消息队列的大小为1000；

9. 设置ROS节点的循环频率 loop_rate 为30Hz，用于控制ROS节点的主循环的执行频率;

10. 定义视频文件的输出路径 outputVideoPath 为：`/home/nvidia/catkin_ws/hffl.avi`；

11. 创建一个 VideoCapture 类的对象capture，绑定视频设备路径： `/dev/video-fl`，用于从该设备获取视频流；

12. 设置帧 S 大小为640x480；

13. 创建一个视频写入器类 VideoWriter 的对象 outputVideo，用于将视频帧写入到指定的输出视频文件中：

	1. 输出视频文件的路径为 outputVideoPath；  
	2. 指定视频编解码器为 MP42；
	3. 视频的帧率为30 帧/秒；
	4. 视频帧的大小为 S：640x480；
	5. 输出视频文件为彩色；

14. 设置视频流的高度为480像素；

15. 设置视频流的宽度为640像素；

16. 设置视频流的饱和度为100，用于调整视频流的图像质量；

17. 检查视频捕获对象 `capture` 是否成功打开了指定的视频设备：`capture.isOpened()` 返回 `true` 表示设备成功打开；返回 `false` 表示设备未能打开或者出现了问题：输出错误信息（`cannot open the camera.`）到控制台，等待用户按下回车键后程序退出并返回错误代码 `-1`；

18. 使用 `VideoCapture` 对象 `capture` 从视频设备中读取一帧视频数据，并将该帧数据存储到 `cv::Mat` 类型（存储图像数据类）的对象 `frame` 中；

19. 调用了名为 `BigImage` 的函数，并将当前帧 `frame` 作为参数传递给该函数，函数返回的处理后的图像帧会被赋值给 `frame`，覆盖原始的帧数据。

	`BigImage` 函数内容 ==这个函数貌似存在问题，最终调整的仅仅是图像的大小，但却操作了一系列的临时变量==：

	1. 参数为 `Mat` 类的 `img`；
	2. 克隆输入图像 `img` 至 `img_temp`，避免直接修改原始图像数据；
	3. 创建一个 `Mat` 类对象 `imgROI`，用于存储感兴趣区域（ROI）的图像数据；
	4. 创建一个 `Mat` 类对象 `roiResize`，用于存储调整大小后的感兴趣区域图像。
	5. 创建一个 `Mat` 类对象 `tranPart`，用于存储从输入图像 `img_temp` 中提取的指定范围的图像部分；
	6. 使用 `Rect` 类创建一个矩形区域并赋值给  `imgROI`：其左上角坐标为 `(camera_x, camera_y)`，宽度为 `camera_h`，高度为 `camera_w`；
		1. `cv::Mat` 类重载了 `()` 操作符，使其可以接受 `Rect` 对象作为参数，用于提取图像中指定矩形区域的子图像（感兴趣区域）；
		2. 将提取的感兴趣区域赋值给 `imgROI`；
	7. 使用 `Range` 类构造函数从图像 `img_temp` 中提取指定范围的图像部分，并赋值给 tranPart。
		1. 这里提取的范围是从行0到479（高度为480），列0到639（宽度为640）的图像数据，并赋值给 `tranPart`。
	8. 使用 `resize` 函数（调整图像大小的函数）将 `imgROI` 调整为与原图像 `img_temp` 相同大小的图像，即宽度为 `img_temp.cols`，高度为 `img_temp.rows`；调整后的图像存储在 `roiResize` 中；
	9. 将调整大小后的 `roiResize` 图像数据复制到 `tranPart` 对应的位置，实现将调整后的感兴趣区域覆盖回原图像 `img_temp` 的指定范围内；
	10. 返回经过处理后的图像副本 `img_temp`，包含了从输入图像 `img` 中提取的感兴趣区域经过调整后的图像数据和覆盖的部分。

20. 检查视频文件写入器 `outputVideo` 是否成功打开。在视频写入过程中，首先会尝试打开指定路径的视频文件，如果打开失败（即视频写入器 `outputVideo` 的状态为未打开），则会输出错误信息：`fail to open!`，并返回一个错误代码 `-1`，表示打开失败。

21. 将 Mat 类对象 `frame` 中的图像数据赋值给变量  Mat 类对象`src`；

22. 初始化了一个整数变量 `jpgnum` 和一个字符数组 `ad`；

23. 创建了一个 `vector<int>` 类型的变量 `compression_params`，用于设置图像保存时的压缩参数，这里使用了 JPEG 格式保存图像，并设置了压缩质量为 `80`；

24. 创建了一个和 Mat 类对象 `src` 大小相同、单通道（灰度图）的空白图像 `src_gray1`，用于存储处理后的图像数据；

25. 遍历图像 `src` 的每一行：

	1. 获取图像 `src` 第 `i` 行的指针，指向该行像素数据的起始位置（可以随着i的变换切换当前行）；
	2. 获取图像 `src_gray1` 第 `i` 行的指针，用于写入处理后的像素数据（可以随着i的变换切换当前行）；
	3. 遍历每行的像素数据，每次跳过三个像素（对应 RGB 三个颜色通道），其中 `j` 控制输入图像中的像素位置（初始为 0 ，每次加3），`z` 控制输出图像中的像素位置（初始为 0 ，每次加1）；
		1. 判断当前像素的绿色分量值是否小于蓝色分量值或红色分量值：
			1. 如果条件成立，将输出图像 `src_gray1` 中对应位置的像素值设为 `0`，表示该像素被判定为偏向蓝色或红色；
			2. 否则，根据公式 `(3 * inData[j + 1] - inData[j] - inData[j + 2])/2` 计算新的像素值，使用 `saturate_cast<uchar>` 进行饱和转换，确保计算结果在 `uchar` 类型的取值范围内（0 到 255），然后将结果存储到 `src_gray1` 中对应位置。

26. 声明一个 `Mat` 对象 `threshold_img1`，用于存储阈值化后的图像；

27. 调用 `OTSU` 函数计算灰度图像 `src_gray1` 的 Otsu 分割阈值，并将结果赋给 `otsu_num`：

	 `OTSU` 函数：`平均灰度值 = 加权灰度和 / 像素概率和`

	1. 输入参数：`Mat` 类对象 `srcImage`；

	2. 获取输入图像 `srcImage` 的列数（nCols）和行数（nRows）；

	3. 初始化阈值 threshold 为 0，用于存储计算得到的最优阈值；

	4. 定义用于统计的数组，`nSumPix` 存储每个灰度级的像素数量，`nProDis` 存储每个灰度级的像素分布比例；

	5. 初始化上述两个统计数组，将所有元素初始化为0；

	6. 统计灰度级（0-255）中每个像素在整幅图像中的个数：

		1. 如果像素值小于 0 或者大于等于256，则输出：`yue jie`，并暂停程序；
		2. 如果在合理范围内，则根据获取的灰度值，将对应的 `nSumPix` 数组中的计数值加1。这个数组用于统计每个灰度级在图像中出现的像素数量。

	7. 计算每个灰度级占图像中的概率分布(即求占总像素百分比)；

	8. 遍历灰度级 [0，255]，计算出最大类间方差下的阈值：

		1. 定义一系列变量 w0, w1, u0_temp, u1_temp, u0, u1, delta_temp，用于计算类内均值、权重以及类间方差等参数；

		2. 初始化最大类间方差为0；

		3. 遍历所有可能的灰度级，根据当前阈值 `i` 将像素分为两类：背景（灰度值 `<= i`）和前景（灰度值 `> i`）：

			1. 如果 `j <= i`，将像素归为背景类，更新背景类的总概率 `w0` 和灰度值总和 `u0_temp`；
			2. 否则，将像素归为前景类，更新前景类的总概率 `w1` 和灰度值总和 `u1_temp`；

		4. 计算背景类的平均灰度 `u0`；

		5. 计算前景类的平均灰度 `u1`；

		6. 计算当前阈值 `i` 下的类间方差 `delta_temp = (float)(w0 * w1 * pow((u0 - u1), 2))`；

			具体解释如下：

			- `w0`：背景像素的权重（概率）。
			- `w1`：前景像素的权重（概率）。
			- `u0`：背景像素的平均灰度值。
			- `u1`：前景像素的平均灰度值。

			这个公式的含义是计算类间方差，其中 `(u0 - u1)` 是两个类别之间的平均灰度差异，而 `pow((u0 - u1), 2)` 是平均灰度差异的平方。

			- `delta_temp = (w0 * w1 * pow((u0 - u1), 2))` 表示类间方差，是背景和前景像素灰度分布之间的加权平方差，用于衡量图像在当前阈值下的分割效果。OTSU算法的核心思想是寻找使类间方差最大的阈值，以实现最佳的图像分割效果。

		7. 如果当前类间方差大于已记录的最大类间方差 `delta_max`，则更新最大类间方差和阈值 `threshold`

	9. 返回计算得到的最佳阈值 threshold。

28.   使用 OpenCV 库中的 `threshold` 函数对灰度图像 `src_gray1` 进行阈值处理（灰度值大于阈值 `30` 的像素将被设置为 `255`（白色），灰度值小于等于阈值 `30` 的像素将被设置为 `0`（黑色）），并将结果保存到 `threshold_img1` 中；

29. 使用 $3*3$ 的核进行中值滤波（medianBlur），去除图像中的噪声或细节，平滑图像，将结果覆盖图像 `threshold_img1`；

30. 创建指定形状（矩形）和大小（$3*3$）的形态学操作的结构元素 kernel1（卷积核）;

31. 使用形态学开运算 (morphologyEx) 对滤波后的图像进行进一步的形态学处理，处理结果仍覆盖 threshold_img1；

28. 









## 4、hfflowerfr.cpp





## 5、plan1.cpp







# 3、launch文件

## 1、hf.launch

1. 设置 `~control_rate` 的值为 10；

2. 启动 mower_ctrl 功能包的 hfflower.py 文件：

	参数 `~control_rate` 设置为 10；

	参数 ==`~linear_yk`== 设置为 0.75；

	参数 ==`~linear_zk`== 设置为 0.25；

	参数 ==`~linear_allk`== 设置为 0.5；

	参数 ==`~near_ul`== 设置为 1500；

	参数 ==`~far_ul`== 设置为 2000。

3. 启动 mower_ctrl 功能包的 hfserial.py 文件：

	参数 `~control_rate` 设置为 10；



## 2、mower_ctrl.launch

1. 启动功能包 joy 的类型  **joy_node**，节点名为 **joy_node**，

	`~autorepeat_rate` 的值设为 10；

2. 启动功能包 **mower_ctrl** 的 **motion_ctrl.py** 文件，节点名为：**motion_ctrl**：

	设置参数 `~control_rate` 为 外部参数`~control_rate` 的值；

3. 启动功能包 mower_ctrl 的  joystick_ctrl.py 文件，节点名为：joystick_ctrl：

	设置参数 `~speed_range` 为 0.5；

	设置参数 `~angle_range` 为1.0；




## 3、lining_ctrl.launch

1. 设置 `~control_rate` 的值为 10；

2. 启动功能包 **mower_ctrl**  的 **motion_ctrl.py** 文件，节点名为：**motion_ctrl**：

	设置参数 `~control_rate` 为 外部参数 `~control_rate`  的值；

3. 启动功能包 **mower_ctrl**  的 **lining_ctrl.py** 文件，节点名为：**lining_ctrl**：

	设置参数 `~d_weight` 的值为 1；

	设置参数 `~kp` 的值为 `-0.5`；

	设置参数 `~kd` 的值为 `-13.3`；

	设置参数 `~lining_speed` 的值为 1；

	设置参数 `~control_rate` 的值为 `$(arg ~control_rate)`，即：值为 10；

	

## 4、lining_visual.launch

1. 设置 `~control_rate` 的值为 10；

2. 启动功能包 **flowers**  的 **plan1.py** 文件，节点名为：**plan1**：









# 4、未使用代码

## 1、BYGPS_reader.py

### 1、程序解析

#### 类：

##### 类1：GPSReader

###### 方法1：初始化（init）

1. 初始化 匿名 ros 节点：BYGPS_reader；
2. 初始化类中变量 serial_port 的值为参数服务器中的 `~serial_port`，未找到设为  `/dev/ttyTHS1`；
3. 初始化类中变量 serial_baudrate 的值为参数服务器中的 `~serial_baudrate`，未找到设为  `115200`；
4. 创建一个正则表达式对象，用于匹配包含逗号 , 或星号 * 的任意单个字符；
5. 打开指定串口，若失败则日志记录：ERROR: fail to open GPS serial port, retrying...；
6. 设置类中变量 gpsx = 3.85，gpsy = 1.97；
7. 初始化类中变量 control_rate 的值为参数服务器中的 `~control_rate`，未找到设为  `10`；
8. 设置ROS 频率控制器 rate 的值为 类中变量 control_rate 的值；
9. 创建发布者：
	1. pose2D_publisher：发送 Pose2D 类型消息，话题名为 “pub_mid_pos”；
	2. path_pub：发送 Path 类型消息，话题名为 “trajectory”；
10. 创建类中变量：pose2D_msg，类型为 Pose2D；
11. 创建类中变量：path_msg，类型为 Path；



###### 方法2：校验数据：CheckData（参数：by_string，参数类型：string）

1. 将 by_string 按照 `*`  进行分割，并将分割后的子串存储在列表 by_string 中；
2. 如果 by_string 的长度不为 2：
	1. 返回False
3. 将 split_string[1] 按照默认的空白字符（空格、制表符、换行符等）进行分割，并将分割后的子串存储在列表 check_string 中；
4. 获取 split_string[0] 字符串中去掉开头字符后的子串，并将该子串存储在变量 data_to_checksum 中；
5. 将 check_sum 的值设为 0；
6. 循环遍历了 split_string[0] 字符串中除第一个字符外的所有字符，将每个字符的 ASCII 值与 check_sum 进行异或操作，最终得到了校验和 check_sum；
7. 校验：`return ("%08X" % check_sum) == check_string.upper()`
	1. 将 check_sum 格式化为一个 8 位的十六进制字符串（左侧）；
	2. 将 check_string 转换为大写形式的字符串（右侧）；
	3. 检查左侧格式化后的字符串是否等于右侧转换为大写形式的字符串。
8. 如果这两个字符串相等，则整个条件表达式的结果为 True，表示校验通过；否则结果为 False，表示校验失败。



###### 方法3：ParseData（参数：by_string，参数类型：string）

1. 使用类中正则表达式 `field_delimiter_regex` 对字符串 by_string 进行分割，并将分割后的结果存储在列表 fields 中；
2. 从列表 fields 的第一个元素中取出一个子串，并将该子串赋值给变量 sentence_type；
3. 如果 sentence_type 的值为 `KSXT` （表示接收到的数据符合特定的类型（KSXT 类型））：
	1. 取出列表 fields 中索引为 10 到 11 的元素（不包括索引 12），然后与 [3, 3] 进行比较。如果这个切片的值等于 [3, 3]，则执行以下操作：
		1. 类中变量 pose2D_msg 的分量 x 设为强制转化为 float 类型后的 fields[14]；
		2. 类中变量 pose2D_msg 的分量 y 设为强制转化为 float 类型后的 fields[15]；
		3. 类中变量 pose2D_msg 的分量 theta 设为强制转化为 float 类型后的 fields[5]；
		4. 使用发布者 pose2D_publisher 发布更新后的 pose2D_msg 消息；
		5. 返回 true，表示处理成功。
	2. 不满足上述条件，返回 Fasle；
4. 不满足上述条件，返回 False。



###### 方法4：DataUpdating（参数：path_pub、path_record，参数类型：Path，nav_msgs/Path）

1. 设置 current_time 为当前时间戳；
2. 配置姿态：
	1. 定义 PoseStamped() 类型的变量 pose，用于表示具有时间戳的位姿信息（姿态）；
	2. 初始化 pose 的各个分量：
		1. 将消息 pose 的时间戳设置为 current_time；
		2. 将消息 pose 的参考坐标系（frame_id）设置为 map；
		3. 将消息 pose 中位姿的 x 坐标设置为 类中变量 gpsx，表示物体在地图坐标系中的 x 轴位置；
		4. 将消息 pose 中位姿的 y 坐标设置为 类中变量 gpsy，表示物体在地图坐标系中的 y 轴位置；
		5. 将消息 pose 中位姿的 x 轴方向的四元数分量设置为 0，表示物体的方向；
		6. 将消息 pose 中位姿的 y 轴方向的四元数分量设置为 0，表示物体的方向；
		7. 将消息 pose 中位姿的 z 轴方向的四元数分量设置为 0，表示物体的方向；
		8. 将消息 pose 中位姿的 w 轴方向的四元数分量设置为 1，表示物体的方向；
3. 配置路径：
	1. 标识 path_record 消息的时间戳和参考坐标系
	2. 存储 pose 消息进入 path_record 消息（path_record 用于存储路径信息，不断向其中添加新的位姿信息）
4. 如果路径记录 path_record  消息超过 1000，自动去除最前排的位姿信息；
5. 通过发布者 path_pub 发布消息 path_record 并在终端打印该信息内容；



##### 方法5：MainLoop()

如果节点正常工作：

1. 逐行读取串口信息存入 data；
2. 类中变量 gpsx 自加 0.5；
3. 类中变量 gpsy 自加1；
4. 类中变量 pose2D_msg 的分量 x 设为强制转化为 float 类型后的 gpsx；
5. 类中变量 pose2D_msg 的分量 y 设为强制转化为 float 类型后的 gpsy ；
6. 类中变量 pose2D_msg 的分量 theta 设为强制转化为 float 类型后的 (gpsx * gpsy )；
7. 使用发布者 pose2D_publisher 发布更新后的 pose2D_msg 消息；
8. 终端打印：pose2D_msg 的值
9. 调用 CheckData() 方法检查串口读取的数据是否符合预期，符合则继续循环，不符合则跳出本次循环；
10. 按设定的频率休眠





## 2、gps_ctrl.launch

1. 设置 `~control_rate` 的值为 10；

2. 启动功能包 **mower_ctrl**  的 **motion_ctrl.py** 文件，节点名为：**motion_ctrl**：

	设置参数 `~control_rate` 为 外部参数`~control_rate` 的值；

3. 启动功能包 **mower_ctrl**  的 **BYGPS_reader.py** 文件，节点名为：**BYGPS_reader**：

	设置参数 `~control_rate` 为 外部参数`~control_rate` 的值；

4. 启动功能包 **mower_ctrl** 的 **local_xy_nav.py** 文件，节点名为：**local_xy_nav**：

	设置参数 `~kp` 为 `-0.5`；

	设置参数 `~kd` 为 `-13.3`；

	设置参数 `~lining_speed` 为 `1`；

	设置参数 `~control_rate` 为外部参数`~control_rate` 的值；

	设置参数 `~land_long` 为 `8`；

	设置参数 `~land_wide` 为 `4`；

	设置参数 `~scan_wide` 为 `2`；









 代码理解：

对行、四轮驱动

四个电机转向、四个电机行走



嵌入式、linux下的开发

ros开发
