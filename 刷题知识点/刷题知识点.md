# 代码随想录

## 数组

### 1、二分查找	leetcode704

leetcode704：给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

示例 1:

```text
输入: nums = [-1,0,3,5,9,12], target = 9     
输出: 4       
解释: 9 出现在 nums 中并且下标为 4     
```

示例 2:

```text
输入: nums = [-1,0,3,5,9,12], target = 2     
输出: -1        
解释: 2 不存在 nums 中因此返回 -1        
```

解析：

第一次使用了一个while循环，复杂度为O(N);

第二次：学习视频教程：利用二分法。

这里讲到了两种区间：左闭右闭和左闭右开两种不同的注意之处：

1. 左闭右闭

	区间的定义这就决定了二分法的代码应该如何写，因为定义 target 在 [left, right] 区间，所以有如下两点：

	- while (left <= right) 要使用 <= ，因为 left == right 是有意义的，所以使用 <=
	- if (nums[middle] > target) right 要赋值为 middle - 1，因为当前这个 nums[middle] 一定不是 target，那么接下来要查找的左区间结束下标位置就是 middle - 1

2. 左闭右开

	- while (left < right)，这里使用 < ,因为 left == right 在区间 [left, right) 是没有意义的
	- if (nums[middle] > target) right 更新为 middle，因为当前 nums[middle] 不等于 target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为 middle，即：下一个查询区间不会去比较 nums[middle]

tips：主要是看区间的值能不能取到！和值有没有比较过！！

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1;
        int middle = 0;
        while(left <= right)
        {
            middle = (left + right) / 2;
            if(target < nums[middle])
                right = middle - 1;
            else if(target > nums[middle])
                left = middle + 1;
            else
                return middle;
        }
        return -1;
    }
};
```

### 2、移除元素	leetcode27

leetcode27：给你一个数组 `nums` 和一个值 `val`，你需要 原地 移除所有数值等于 `val` 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 `O(1)` 额外空间并 原地修改输入数组。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

==TIPS：数组的元素只能覆盖，不能删除==

**示例 1：**

```
输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2]
解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。
```

**示例 2：**

```
输入：nums = [0,1,2,2,3,0,4,2], val = 2
输出：5, nums = [0,1,3,0,4]
解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。
```

错误答案：

```c++
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        // sort(nums.begin(), nums.end());
        int temp = 0;
        int length = nums.size();
        for(int i = 0; i < length; i++)
        {
            if(nums[i] == val)
            {
                length--;
                for(int j = 0; j < length; j++)
                {
                    // temp = nums[i];
                    nums[i] = nums[i+1];
                    // nums[i+1] = temp;
                }    
            }
        }
        return length;
    }
};
```

修改后：没有考虑到数组越界问题，以及删除一个数，指针应该向前挪一位。但复杂度是$O(N^2)$

```c++
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int length = nums.size();
        for(int i = 0; i < length; i++)
        {
            if(nums[i] == val)
            {
                for(int j = i + 1; j < length; j++)
                {
                    nums[j - 1] = nums[j];
                }    
                i--;
                length--;
            }
        }
        return length;
    }
};
```

最优解：双指针法（快慢指针法）复杂度$O(N)$

快指针：筛选出应该留在数组内正确的元素；

慢指针：更新数组的元素。

```c++
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int slowIndex = 0;
        for (int fastIndex = 0; fastIndex < nums.size(); fastIndex++) {
            if (val != nums[fastIndex]) {
                nums[slowIndex++] = nums[fastIndex];
            }
        }
        return slowIndex;
    }
};
```

### 3、有序数组的平方	leetcode977

leetcode977：给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。

示例 1：

- 输入：nums = [-4,-1,0,3,10]
- 输出：[0,1,9,16,100]
- 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]

示例 2：

- 输入：nums = [-7,-3,2,3,11]
- 输出：[4,9,9,49,121]

自身答案：复杂度$O(N^2)$

```c++
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        int size = nums.size();
        for(int i = 0; i < size; i++)
        {
            nums[i] = nums[i] * nums[i];
        }
        for(int j = 0; j < size; j++)
        {
            for(int m = j+1; m < size; m++)
            {
                if(nums[j] > nums[m])
                {
                    int temp = 0;
                    temp = nums[j];
                    nums[j] = nums[m];
                    nums[m] = temp;
                }          
            }
        }
        return nums;
    }
};
```

代码随想录答案1：暴力排序（借助了 sort 函数）；时间复杂度$O(nlogn)$

```c++
class Solution {
public:
    vector<int> sortedSquares(vector<int>& A) {
        for (int i = 0; i < A.size(); i++) {
            A[i] *= A[i];
        }
        sort(A.begin(), A.end()); // 快速排序
        return A;
    }
};
```

代码随想录答案2：双指针法；复杂度为$O(logN)$

如动画所示：

![img](刷题知识点.assets/977.有序数组的平方.gif)

```c++
class Solution {
public:
    vector<int> sortedSquares(vector<int>& A) {
        int k = A.size() - 1;
        vector<int> result(A.size(), 0);
        for (int i = 0, j = A.size() - 1; i <= j;) { // 注意这里要i <= j，因为最后要处理两个元素
            if (A[i] * A[i] < A[j] * A[j])  {
                result[k--] = A[j] * A[j];
                j--;
            }
            else {
                result[k--] = A[i] * A[i];
                i++;
            }
        }
        return result;
    }
};
```

==Tips:==

在C++中，你不能在循环的初始化部分同时定义两个变量，如下面的代码所示：

```c++
for(int k = 0, int m = length; k <= m; )
```

应该将定义分开写，如下所示：

```c++
for(int k = 0, m = length; k <= m; )
```

或者在循环外部分别定义它们，然后再在循环中初始化：

```c++
int k = 0;
int m = length;
for(; k <= m; )
```



### 4、长度最小的子数组	leetcode 209

leetcode 209：给定一个含有 `n` 个正整数的数组和一个正整数 `target` 。找出该数组中满足其总和大于等于 `target` 的长度最小的 **连续子数组** `[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度**。**如果不存在符合条件的子数组，返回 `0` 。

**示例 1：**

```
输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
```

**示例 2：**

```
输入：target = 4, nums = [1,4,4]
输出：1
```

**示例 3：**

```
输入：target = 11, nums = [1,1,1,1,1,1,1,1]
输出：0
```

自身答案：两个 for 循环；复杂度为 $O(N^2)$ ；但力扣提交超出了时间限制。

```c++
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int i;
        int size = nums.size();
        int length = size + 1;

        for(i = 0; i < size; i++)
        {
            int sum = 0;
            int times = 0;
            for(int j = i; j < size; j++)
            {
                sum += nums[j];
                times++;
                if(sum >= target)
                {
                    if(length > times)
                    {
                        length = times;
                    }
                    break;
                }
            }
        }
        if(length == (size + 1))
            return 0;
        else
            return length;
    }
};
```



最优解：滑动窗口法

所谓滑动窗口，**就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果**。

在暴力解法中，是一个for循环滑动窗口的起始位置，一个for循环为滑动窗口的终止位置，用两个for循环 完成了一个不断搜索区间的过程。

那么滑动窗口如何用一个for循环来完成这个操作呢。

首先要思考 如果用一个for循环，那么应该表示 滑动窗口的起始位置，还是终止位置。

如果只用一个for循环来表示 滑动窗口的起始位置，那么如何遍历剩下的终止位置？

此时难免再次陷入 暴力解法的怪圈。

所以 只用一个for循环，那么这个循环的索引，一定是表示 滑动窗口的终止位置。

那么问题来了， 滑动窗口的起始位置如何移动呢？

这里还是以题目中的示例来举例，s=7， 数组是 2，3，1，2，4，3，来看一下查找的过程：

![209.长度最小的子数组](刷题知识点.assets/209.长度最小的子数组.gif)

最后找到 4，3 是最短距离。

其实从动画中可以发现滑动窗口也可以理解为双指针法的一种！只不过这种解法更像是一个窗口的移动，所以叫做滑动窗口更适合一些。

在本题中实现滑动窗口，主要确定如下三点：

- 窗口内是什么？
- 如何移动窗口的起始位置？
- 如何移动窗口的结束位置？

窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。

窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）。

窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，也就是for循环里的索引。

解题的关键在于 窗口的起始位置如何移动，如图所示：

![leetcode_209](刷题知识点.assets/20210312160441942.png)

可以发现**滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)暴力解法降为O(n)。**

```c++
class Solution {
public:
    int minSubArrayLen(int s, vector<int>& nums) {
        int result = INT32_MAX;
        int sum = 0; // 滑动窗口数值之和
        int i = 0; // 滑动窗口起始位置
        int subLength = 0; // 滑动窗口的长度
        for (int j = 0; j < nums.size(); j++) {
            sum += nums[j];
            // 注意这里使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件
            while (sum >= s) {
                subLength = (j - i + 1); // 取子序列的长度
                result = result < subLength ? result : subLength;
                sum -= nums[i++]; // 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）
            }
        }
        // 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列
        return result == INT32_MAX ? 0 : result;
    }
};
```

